<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hang'blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-06T09:29:22.186Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Hang Weiping]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[c++第一季之经常考察的关键字]]></title>
    <link href="http://yoursite.com/2016/03/06/%E7%BB%8F%E5%B8%B8%E8%80%83%E5%AF%9F%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/03/06/经常考察的关键字/</id>
    <published>2016-03-06T08:41:34.000Z</published>
    <updated>2016-03-06T09:29:22.186Z</updated>
    <content type="html"><![CDATA[<h2 id="sizeof">sizeof</h2><blockquote>
<p>单目运算符（例如i++），计算发生在编译时刻，所以可以当作常量表达式，括号内的运算会被忽略。<br><a id="more"></a></p>
<h3 id="sizeof使用场合。">sizeof使用场合。</h3></blockquote>
<ol>
<li><p>sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。例如：　</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>　*<span class="built_in">malloc</span>（<span class="keyword">size_t</span>　size）</span><br><span class="line"><span class="keyword">size_t</span>　fread(<span class="keyword">void</span>　*　ptr,<span class="keyword">size_t</span>　size,<span class="keyword">size_t</span>　nmemb,FILE　*　stream)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用它可以看看一类型的对象在内存中所占的单元字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*　<span class="built_in">memset</span>（<span class="keyword">void</span>　*　s,<span class="keyword">int</span>　c,<span class="keyword">sizeof</span>(s)）</span><br></pre></td></tr></table></figure>
</li>
<li><p>在动态分配一对象时,可以让系统知道要分配多少内存。</p>
</li>
<li>便于一些类型的扩充,在windows中就有很多结构内型就有一个专用的字段是用来放该类型的字节大小。</li>
<li>由于操作数的字节数在实现时可能出现变化，建议在涉及到操作数字节大小时用sizeof来代替常量计算。</li>
<li>如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小。</li>
</ol>
<h3 id="sizeof深入理解。">sizeof深入理解。</h3><ol>
<li>sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned　int类型。该类型保证能容纳实现所建立的最大对象的字节大小。</li>
<li>sizeof是算符，strlen是函数。</li>
<li>sizeof可以用类型做参数，<strong>strlen只能用char*做参数，且必须是以’’\0’’结尾的</strong>。sizeof还可以用函数做参数，比如：<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short f<span class="list">()</span><span class="comment">;</span></span><br><span class="line">printf<span class="list">(<span class="string">"%d\n"</span>, sizeof<span class="list">(<span class="keyword">f</span><span class="list">()</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出的结果是sizeof(short)，即2。</p>
<ol>
<li>数组做sizeof的参数不退化，传递给strlen就退化为指针了。</li>
<li><p>大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">20</span>]=<span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">int</span> a=strlen(<span class="keyword">str</span>); <span class="comment">//a=10;</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="keyword">sizeof</span>(<span class="keyword">str</span>); <span class="comment">//而b=20;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。</p>
</li>
<li>sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。</li>
<li>当适用了于一个结构类型时或变量， sizeof 返回实际的大小， 当适用一静态地空间数组， sizeof 归还全部数组的尺 寸。 sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸</li>
<li>数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，如：<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span> [<span class="number">8</span>])</span><br><span class="line"><span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span> [])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>都等价于 fun(char *) 在C++里传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小如果想在函数内知道数组的大小， 需要这样做：进入函数后用memcpy拷贝出来，长度由另一个形参传进去<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun(unsiged <span class="keyword">char</span> *p1, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[len+<span class="number">1</span>]</span><br><span class="line"><span class="built_in">memcpy</span>(buf, p1, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有关内容见： C++ PRIMER</p>
<ol>
<li>计算结构变量的大小就必须讨论数据对齐问题。为了CPU存取的速度最快（这同CPU取数操作有关，详细的介绍可以参考一些计算机原理方面的书），C++在处理数据时经常把结构变量中的成员的大小按照4或8的倍数计算，这就叫数据对齐（data alignment）。这样做可能会浪费一些内存，但理论上速度快了。当然这样的设置会在读写一些别的应用程序生成的数据文件或交换数据时带来不便。MS VC++中的对齐设定，有时候sizeof得到的与实际不等。一般在VC++中加上#pragma pack(n)的设定即可.或者如果要按字节存储，而不进行数据对齐，可以在Options对话框中修改Advanced compiler页中的Data alignment为按字节对齐。</li>
<li>sizeof操作符不能用于函数类型，不完全类型或位字段。不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。如sizeof(max)若此时变量max定义为int　max(),sizeof(char_v)　若此时char_v定义为char　char_v　[MAX]且MAX未知，sizeof(void)都不是正确形式.</li>
</ol>
<h4 id="第一个例子">第一个例子</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* ss = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(ss) 结果 <span class="number">4</span> ＝＝＝》ss是指向字符串常量的字符指针</span><br><span class="line"><span class="keyword">sizeof</span>(*ss) 结果 <span class="number">1</span> ＝＝＝》*ss是第一个字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ss[] = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(ss) 结果 <span class="number">11</span> ＝＝＝》ss是数组，计算到\<span class="number">0</span>位置，因此是<span class="number">10</span>＋<span class="number">1</span></span><br><span class="line"><span class="keyword">sizeof</span>(*ss) 结果 <span class="number">1</span> ＝＝＝》*ss是第一个字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">100</span>] = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(ss) 结果是<span class="number">100</span> ＝＝＝》ss表示在内存中的大小 <span class="number">100</span>×<span class="number">1</span></span><br><span class="line">strlen(ss) 结果是<span class="number">10</span> ＝＝＝》strlen是个函数内部实现是用一个循环计算到\<span class="number">0</span>为止之前</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ss[<span class="number">100</span>] = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(ss) 结果 <span class="number">400</span> ＝＝＝》ss表示再内存中的大小 <span class="number">100</span>×<span class="number">4</span></span><br><span class="line">strlen(ss) 错误 ＝＝＝》strlen的参数只能是<span class="keyword">char</span>* 且必须是以<span class="string">''</span>\<span class="number">0</span><span class="string">''</span>结尾的</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> q[]=<span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> p[]=<span class="string">"a\n"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(q),<span class="keyword">sizeof</span>(p),strlen(q),strlen(p);</span><br><span class="line">结果是 <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="第二个例子">第二个例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">char</span> k;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(X)&lt;&lt;endl; 结果 <span class="number">12</span> ＝＝＝》内存补齐</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(x)&lt;&lt;endl; 结果 <span class="number">12</span> 同上</span><br></pre></td></tr></table></figure>
<h4 id="第三个例子">第三个例子</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="value">char</span> szPath<span class="attr_selector">[MAX_PATH]</span></span><br></pre></td></tr></table></figure>
<p>如果在函数内这样定义，那么sizeof(szPath)将会是MAX_PATH，但是将szPath作为虚参声明时（void fun(char szPath[MAX_PATH])）,sizeof(szPath)却会是4(指针大小).</p>
<h3 id="sizeof计算的是在栈中分配的内存大小。">sizeof计算的是在栈中分配的内存大小。</h3><ol>
<li>sizeof不计算static变量占得内存；</li>
<li>指针的大小一定是4个字节，而不管是什么类型的指针；</li>
<li>char型占1个字节，int占4个字节，short int占2个字节 long int占4个字节，float占4字节，double占48字节，string占4字节,一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节;</li>
<li>数组的长度：若指定了数组长度，则不看元素个数，总字节数=数组长度<em>sizeof（元素类型） ,若没有指定长度，则按实际元素个数类确定.<em>*多维数组要乘以维度。</em></em>Ps：若是字符数组，则应考虑末尾的空字符。</li>
<li>结构体对象的长度<br>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</li>
<li>unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4 </li>
<li>自定义类型的sizeof取值等于它的类型原型取sizeof;</li>
<li>对函数使用sizeof，在编译阶段会被函数的返回值的类型代替;</li>
<li>sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符;</li>
<li>当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸.</li>
</ol>
<h3 id="sizeof与strlen的区别？">sizeof与strlen的区别？</h3><ol>
<li>sizeof的返回值类型为size_t（unsigned int）；</li>
<li>sizeof是运算符，而strlen是函数；</li>
<li>sizeof可以用类型做参数，其参数可以是任意类型的或者是变量、函数，而strlen只能用char*做参数，且必须是以’\0’结尾；</li>
<li>数组作sizeof的参数时不会退化为指针，而传递给strlen是就退化为指针；</li>
<li>sizeo是编译时的常量，而strlen要到运行时才会计算出来，且是字符串中字符的个数而不是内存大小； </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="sizeof">sizeof</h2><blockquote>
<p>单目运算符（例如i++），计算发生在编译时刻，所以可以当作常量表达式，括号内的运算会被忽略。<br>]]>
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速排序]]></title>
    <link href="http://yoursite.com/2016/02/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2016/02/13/快速排序/</id>
    <published>2016-02-13T11:19:06.000Z</published>
    <updated>2016-03-01T10:33:37.901Z</updated>
    <content type="html"><![CDATA[<p><em>快速排序算法和归并排序类似，都是属于分治算法。</em></p>
<h4 id="常见面试题：">常见面试题：</h4><blockquote>
<ol>
<li>线性表所有奇数移动到偶数前；</li>
<li>数组中找到第K小的元素；</li>
<li>荷兰国旗问题。</li>
</ol>
</blockquote>
<h4 id="快速排序使用分治法（Divide_and_conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。">快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</h4><p>步骤为：</p>
<p>从数列中挑出一个元素，称为 “基准”（pivot），重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。虽然快速排序是分治算法，但其中主要的操作是分区操作，这个操作的复杂性应该是线性的。划分的实现由很多种，朴素的实现是选取第一个元素和最后一个元素作为基准作为划分。算法导论一书给出的partition 函数是取最后一个元素作为基准，然后通过一遍循环交换元素。代码虽然简洁，但是初看起来不太易懂，建议在纸上模拟下过程。此种方法相对来说交换元素的次数也比较多，后面会给出一种优化的操作。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言实现</span></span><br><span class="line"><span class="comment">/* 快速排序朴素的实现 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取最后一个作为基准 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span> <span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = arr[h];   </span><br><span class="line">    <span class="keyword">int</span> i = (l - <span class="number">1</span>);  <span class="comment">// 较小元素的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= h- <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;    <span class="comment">//增加较小元素的下标</span></span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[i + <span class="number">1</span>], &amp;arr[h]);  </span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);<span class="comment">//返回基准元素的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* arr[] --&gt; 待排序数组, l  --&gt; 开始位置, h  --&gt;结束位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, l, h); <span class="comment">/* p为划分的中间位置 */</span></span><br><span class="line">        quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sorted array: \n"</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sorted <span class="built_in">array</span>:</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>有必要说下上面的partition函数 ，如果输入是已排序的，那个每个元素都会和自己交换，效率不好。另一个种划分的操作是用头尾指针。实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//划分操作的 第二种实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = start;<span class="comment">//指向开头</span></span><br><span class="line">	<span class="keyword">int</span> j = end + <span class="number">1</span>;<span class="comment">//指向结尾</span></span><br><span class="line">	<span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>( i&lt;end &amp;&amp; arr[++i] &lt; pivot);<span class="comment">//从前到后  第一个比 基准（x）大的数。 j指向该数</span></span><br><span class="line">		<span class="keyword">while</span>(j&gt;start &amp;&amp; arr[--j] &gt; pivot);<span class="comment">//从后向前找到第一个比 基准（x）小的数。i指向该数</span></span><br><span class="line">		<span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		swap(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	arr[start] = arr[j];</span><br><span class="line">	arr[j] = pivot;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种划分操作在大部分情况下交换的次数较少。</p>
<p>分析<br>时间的复杂度可以表示为：T(n) = T(k) + T(n-k-1) + \theta(n)其中T(k),T(n-k-1)对应程序中的递归调用，k是在划分后比基准元素小的元素个数。\theta(n)就是partition函数的复杂度。</p>
<p>算法的效率对不同的输入数据会有所不同，可以分为下面3中情况：</p>
<p>1) 最坏的情况。当分区过程总是挑选最大或最小的元素作为支点。如果我们考虑以上的分区策略，其中最后一个元素总是被挑为支点，当数组已经排序的递增或递减顺序时，会发生最坏的情况：T(n) = T(0) + T(n-1) +\theta(n), 即 T(n) = T(n-1) +\theta(n)此时的复杂度为 O(n^2)</p>
<p>2) 最好的情况。发生在最好的情况下，当分区过程总是挑选最中间元素为支点。T(n) = 2 T(n/2) +\theta(n)此时的递归表达式和归并排序是一样的。时间时间复杂度为 O(n lg n). 计算方法参考 递归的时间复杂度</p>
<p>3） 平均情况。<br>要做到平均情况分析，我们需要考虑数组中的所有可能的排列，并计算每一个排列所需要的时间，这种计算是比较麻烦的。可以这么分析，如果划分的结果是这样的两部分 O(n/10) 和 O(9n/10)。递归式为：  T(n) =  T(n/10) + T(n9/10) +\theta(n)最终的计算结果也为：O(n lg n). 虽然快速排序的最坏情况下复杂度为O(N^2)，这比很多其他的排序算法，如归并排序和堆排序，在实践中更快，因为它的内部循环可以在大多数架构有效地实现，对于大部分真实的数据，也是比较高效的。后续会有快速排序的优化算法</p>
<h4 id="基准(支点_pivot)元素选取">基准(支点 pivot)元素选取</h4><p>如果基准(支点 pivot)元素选取的不当，复杂度最坏为O(n^2)。一般有下面的几个优化方法：</p>
<p>1）以上实现使用最后一个元素作为支点。如果输入是已排序的数组，这是一种最坏的情况。解决这种情况，主要在于怎么选取支点。可以随机的选取一个元素作为支点进行划分，或者直接选择最中间的元素，或者选择第一个元素first、中间元素middle和最后一个元素last 的 中位数。比较常用的是随机化方法。</p>
<p>2）为了减少递归深度，首先对数组更小的一半进行递归，并使用尾调用递归另一半。</p>
<p>3）在数组长度较小时使用插入排序是个不错的选择。例如这个库 的实现是当数组长度小于7时用插入排序。随机化的实现也比较简单，划分的操作可以继续以最后一个元素为支点，只是先随机的选取一个元素，然后和最后一个元素交换。另外可以把递归的调用，可以改成非递归的，以减少开销。这里直接用数据模拟栈来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通划分操作。以最后一个元素 arr[e]作为基准</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = s-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = s; j&lt;e; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[j] &lt;= arr[e])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			swap(arr[i], arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[e], arr[i+<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机化的划分操作。已最后一个元素 arr[e]作为基准</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partitionRandom</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="comment">//取得一个随机的下标</span></span><br><span class="line">	<span class="keyword">int</span> randomIndex = rand() % (e-s+<span class="number">1</span>) + s;</span><br><span class="line">	swap(arr[e], arr[randomIndex]);</span><br><span class="line">	<span class="keyword">int</span> i = s-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = s; j&lt;e; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[j] &lt;= arr[e])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			swap(arr[i], arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[e], arr[i+<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归的实现。A[] --&gt;要排序的数组, s  --&gt; 开始位置, e  --&gt; 结束位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, s, e); <span class="comment">/* Partitioning index */</span></span><br><span class="line">        quickSort(arr, s, p - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p + <span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分操作的 第二种实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = start;<span class="comment">//指向开头</span></span><br><span class="line">	<span class="keyword">int</span> j = end + <span class="number">1</span>;<span class="comment">//指向结尾</span></span><br><span class="line">	<span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>( i&lt;end &amp;&amp; arr[++i] &lt; pivot);<span class="comment">//从前到后  第一个比 基准（x）大的数。 j指向该数</span></span><br><span class="line">		<span class="keyword">while</span>(j&gt;start &amp;&amp; arr[--j] &gt; pivot);<span class="comment">//从后向前找到第一个比 基准（x）小的数。i指向该数</span></span><br><span class="line">		<span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		swap(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	arr[start] = arr[j];</span><br><span class="line">	arr[j] = pivot;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序的非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksortIterative</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">stack</span>[e-s+<span class="number">1</span>];<span class="comment">//用数组模拟栈</span></span><br><span class="line">	<span class="built_in">stack</span>[<span class="number">0</span>] = s;</span><br><span class="line">	<span class="built_in">stack</span>[<span class="number">1</span>] = e;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">2</span>; <span class="comment">//栈的大小</span></span><br><span class="line">	<span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//取得时候是反着的</span></span><br><span class="line">		<span class="keyword">int</span> end = <span class="built_in">stack</span>[--len];</span><br><span class="line">		<span class="keyword">int</span> start = <span class="built_in">stack</span>[--len];</span><br><span class="line">		<span class="keyword">int</span> mid = partitionRandom(arr, start, end);</span><br><span class="line">		<span class="comment">//只有元素个数大于1的时候，才放入栈中</span></span><br><span class="line">		<span class="keyword">if</span>(mid-<span class="number">1</span> &gt; start)&#123;</span><br><span class="line">			<span class="built_in">stack</span>[len++] = start;</span><br><span class="line">			<span class="built_in">stack</span>[len++] = mid-<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(end &gt; mid+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">stack</span>[len++] = mid+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">stack</span>[len++] = end;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	quicksortIterative(arr, <span class="number">0</span> ,n-<span class="number">1</span>);</span><br><span class="line">	printArr(arr,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><em>快速排序算法和归并排序类似，都是属于分治算法。</em></p>
<h4 id="常见面试题：">常见面试题：</h4><blockquote>
<ol>
<li>线性表所有奇数移动到偶数前；</li>
<li>数组中找到第K小的元素；</li>
<li>荷兰国旗问题。</li>
</ol>
</blockquote>
<h4 id="快速排序使用分治法（Divide_and_conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。">快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</h4><p>步骤为：</p>
<p>从数列中挑出一个元素，称为 “基准”（pivot），重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。虽然快速排序是分治算法，但其中主要的操作是分区操作，这个操作的复杂性应该是线性的。划分的实现由很多种，朴素的实现是选取第一个元素和最后一个元素作为基准作为划分。算法导论一书给出的partition 函数是取最后一个元素作为基准，然后通过一遍循环交换元素。代码虽然简洁，但是初看起来不太易懂，建议在纸上模拟下过程。此种方法相对来说交换元素的次数也比较多，后面会给出一种优化的操作。<br>]]>
    
    </summary>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ io库]]></title>
    <link href="http://yoursite.com/2015/10/18/c++%20io%E5%BA%93/"/>
    <id>http://yoursite.com/2015/10/18/c++ io库/</id>
    <published>2015-10-18T11:29:34.000Z</published>
    <updated>2016-04-15T11:00:53.022Z</updated>
    <content type="html"><![CDATA[<h1 id="一、管理输出缓冲">一、管理输出缓冲</h1><p>每个输出流都会管理一个输出缓冲区，用来保存程序读写的数据。比如：<br>cout&lt;&lt;Please input a number&lt;&lt;endl;<br>这样文本串可能被立即打印出来，也可能先被操作系统保存到缓冲区，然后再打印。设备的写操作可能是费时的，这样，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作或者单一的设备写操作可带来性能上的很大提升。</p>
<a id="more"></a>
<p>  下面总结了导致缓冲刷新的原因：</p>
<ol>
<li><p>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。</p>
</li>
<li><p>缓冲区满时需要刷新缓冲区之后新的数据才能被继续写入。</p>
</li>
<li><p>操纵符endl可以显示刷新缓冲区</p>
</li>
<li><p>在每个输出操作之后，可用操纵符unitbuf设置流的内部状态来清空缓冲区。默认情况下对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</p>
</li>
<li><p>一个输出流可能被关联到另一个流。此时，当读写被关联的流时，关联到的流的缓冲区会被刷新。比如，默认情况下cin和cerr都关联到cout，因此，读cin或写cerr都会导致cout的缓冲区被刷新。</p>
</li>
</ol>
<hr>
<h1 id="二、刷新输出缓冲区">二、刷新输出缓冲区</h1><p>使用操纵符endl可以刷新缓冲区并完成换行工作。类似的flush也能刷新缓冲区，但不输出任何额外字符，不像endl那样还会换行。ends则是向缓冲区插入一个空字符，然后刷新缓冲区。他们的用法和endl一样。</p>
<p>如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操纵符来设置流的内部状态清空缓冲区。它告诉流在接下来的每次输出写操作之后都进行一次flush操作，而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<p>cout&lt;&lt;unitbuf;  //现在所有输出操作后都会立即刷新缓冲区<br>cout&lt;&lt;nounitbuf;  //恢复正常的缓冲方式<br>注：如果程序崩溃，输出缓冲区不会被刷新，所有输出数据很可能停留在输出缓冲区等待打印。<br>另外，当输入流被关联到输出流，那么一旦从输入流读取数据，都会先刷新关联的输出流。标准库将cout和cin关联在一起。</p>
<p>所以当执行：</p>
<p>cin&gt;&gt;ival;</p>
<p>时，将导致cout的缓冲区被刷新。这在交互式系统通常应该关联输入流和输出流。即所有输出和用户提示信息都会在读操作之前被打印出来。说道关联输入和输出流，就要说道tie函数，它有两个版本，一个不带参数，返回指向输出流的指针，如果本对象当前关联到一个输出流，则返回这个输出流的指针，如过对象没有关联到流返回空指针。tie还一个版本接受一个指向ostream的指针，将自己关联到次ostream。比如 x.tie(&amp;o)即将流x关联到输出流o 。（&amp;o  这里是对输出流对象o取址）。我们可以将一个istream对象关联到一个ostream对象也可以将一个ostream对象关联到另一个ostream对象。</p>
<p>cin.tie(&amp;cout);  //标准库中的将cin和cout关联在一起<br>如果想解开流的关联，可以将对象tie到一个空指针上，比如：<br>ostearm *old_tie=cin.tie(nullptr);  //cin不再与其他流关联</p>
<hr>
<h1 id="三、文件的输入输出">三、文件的输入输出</h1><h2 id="a-_IO">a. IO</h2><p>头文件fstrem中定义了三个支持文件IO</p>
<ol>
<li><p>ifstream 从给定文件读取数据</p>
</li>
<li><p>ofstream 向给定文件写入数据</p>
</li>
<li><p>fstream 读写给定文件</p>
</li>
</ol>
<p>fstream继承自iostream，所以诸如IO运算符&lt;&lt;  &gt;&gt; cin cout getline等都能适用，另外它还有些新成员来管理与流关联的文件。当然这些时fstream中特有的，可以对fstream ifstream ofstream对象调用。总结如下</p>
<ol>
<li><p>fstream  fstrm;       创建一个未绑定的流，fstream是头文件fstream中定义的一个类型</p>
</li>
<li><p>fstream fstrm(s);   c创建一个fstream，并打开名为s的文件，s可是string类型或是一个指向C风格的字符串指针，这些构造函数是explict的</p>
</li>
<li><p>fstream fstrm(s,mode)  和以上一样，按指定的mode打开文件</p>
</li>
</ol>
<p>fstrm.open(s)    打开名为s的文件，将文件与fstrm绑定，返回void</p>
<p>fstrm.close()    关闭与fstrm绑定的文件，返回void</p>
<p>fstrm.is_open()  返回一个bool值，指出绑定文件是否打开</p>
<h2 id="b-使用文件流对象">b.使用文件流对象</h2><p>  当有需要读写一个文件时，我们可先定义一个文件流对象，并将对象与文件关联绑定。创建文件流对象时，我们可提供文件名（选用），如果提供了文件名open成员函数会被自动调用，比如：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream <span class="keyword">in</span>(ifile);  <span class="comment">//构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream <span class="keyword">out</span>;    <span class="comment">//这是一个输出文件流但还未关联到任何文件</span></span><br></pre></td></tr></table></figure>
<p>我们已经知道，通常我们可以将一个派生类对象当做基类对象使用，因此，在需要iostream类型引用或指针的地方，我们也可用对应的fstream来调用。例如，假定输入输出文件名是通过传递给main函数的参数来指定，可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;  <span class="comment">//打开文件，建立一个文件输入流对象input</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;   <span class="comment">//打开输出文件，建立一个文件输出流对象output</span></span><br></pre></td></tr></table></figure>
<p>再举一例：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream <span class="keyword">in</span>(ifile);  <span class="comment">//构建一个ifstream并打开给定文件</span></span><br><span class="line">ofstream <span class="keyword">out</span>;   <span class="comment">//构建了一个输出文件流，但没有与任何文件绑定</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">open</span>(ifile+<span class="string">".copy"</span>);  将流对象绑定指定文件并打开</span><br></pre></td></tr></table></figure>
<p>像这里要是open失败了，failbit会被置位，调用open是有可能失败的，因为调用open时对它进行检测通常是一个好习惯，它和cin用作条件类似，open要是失败，条件会为假，就不会去使用out流了。比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(out)</span></span>   <span class="comment">//检查open是否成功，成功了，就可以使用文件了</span></span><br></pre></td></tr></table></figure>
<p>一旦文件流打开，它就保持了与对应文件的关联，对一个已打开的文件流调用open会失败，并导致failbit被置位。随后任何试图使用文件流的操作都会失败。这和socket 、serial等一样啊。如果你想改变文件流关联的对象，那么必须先关闭当前已关联的文件，关闭成功后再去关联或者打开新的文件，比如：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">in</span>.<span class="built_in">close</span>();          <span class="comment"> //关闭当前关联的文件</span></span><br><span class="line"><span class="operator">in</span>.<span class="built_in">open</span>(ifile+<span class="string">"2"</span>);  打开另一个文件</span><br></pre></td></tr></table></figure>
<p>一旦open成功，则open会设置流的状态，使得good()为true</p>
<h2 id="c-自动构造和析构">c.自动构造和析构</h2><p> 任务：由main函数接受要处理的一个文件列表，考虑用循环的方式解决问题，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(quto p=argv+<span class="number">1</span>:p!=argv+argc;++p)&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>;  <span class="comment">//创建文件输出流并打开文件</span></span><br><span class="line">  <span class="keyword">if</span>(input)&#123;         <span class="comment">//如果创建成功，处理文件</span></span><br><span class="line">      process(input);</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">      <span class="built_in">cerr</span>&lt;&lt;<span class="string">"couldn't open: "</span>&lt;&lt;<span class="built_in">string</span>(*p);</span><br><span class="line">&#125;  <span class="comment">//每次循环后创建的input流对象会离开作用域，自动销毁</span></span><br></pre></td></tr></table></figure>
<p>上面流对象在每次循环中都将被重新创建和销毁，当一个流对象离开其作用域时，与之关联的文件会自动关闭，即close会被自动调用。 </p>
<hr>
<h1 id="四、文件模式">四、文件模式</h1><p>  文件被open时会涉及文件模式，它指出如何来使用文件，总结如下；</p>
<ol>
<li>in  以读的方式打开文件 </li>
<li><p>out  以写得方式打开文件</p>
</li>
<li><p>app  每次写操作前均定为到文件末尾</p>
</li>
<li><p>ate  打开文件后立即定为到文件末尾</p>
</li>
<li><p>trunc  截断文件</p>
</li>
<li><p>binary  以二进制方式进行IO<br>相关原则如下：</p>
</li>
<li><p>只能对ofstream或fstream对象设定out模式</p>
</li>
<li><p>只能对ifstrem或fstream对象设定in模式</p>
</li>
<li><p>只有当out也被设定时才能设定trunc模式</p>
</li>
<li><p>只要trunc没被设定，就可以设定app模式，在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开</p>
</li>
<li><p>默认情况，即使没有指定trunc，以out模式打开的文件也会被截断，为了保留以out模式打开的文件的内容，必须同时指定app模式，这样只会将数据追加写到文件末尾，或者同时指定in模式，即打开文件同时进行读写操作</p>
</li>
<li><p>每个文件流类型都定义了一个默认的文件模式，总结如下：</p>
</li>
</ol>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream——<span class="keyword">in</span>模式                         ofstream——<span class="keyword">out</span>模式</span><br><span class="line"></span><br><span class="line">fstream—— <span class="keyword">in</span> 和 <span class="keyword">out</span>模式</span><br></pre></td></tr></table></figure>
<p>需要说明的是以out模式打开文件会丢弃已有的数据，默认情况下，打开一个ofstream时文件的内容会被丢弃，然而阻止这一清空给定文件的好办法就是打开的同时指定app模式。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下语句，file会被截断</span></span><br><span class="line">ofstream <span class="keyword">out</span>(<span class="string">"file1"</span>);  <span class="comment">//隐含以输出模式打开文件并截断文件</span></span><br><span class="line">ofstream <span class="keyword">out</span><span class="number">2</span>(<span class="string">"file1"</span>,ofstream::<span class="keyword">out</span>); <span class="comment">//隐含地截断文件</span></span><br><span class="line">ofstream <span class="keyword">out</span><span class="number">3</span>(<span class="string">"file1"</span>,ofstream::<span class="keyword">out</span> | ofstream::trunc)</span><br><span class="line"><span class="comment">//为了保留文件内容，我们必须显示指定app模式</span></span><br><span class="line">ofstream <span class="keyword">out</span>(<span class="string">"file"</span>,ofstream::app);  <span class="comment">//隐含为输出模式</span></span><br><span class="line">ofstream <span class="keyword">out</span><span class="number">2</span>(<span class="string">"file"</span>,ofstream::<span class="keyword">out</span> | ofstream::app);</span><br></pre></td></tr></table></figure>
<p>总结：要想保留被ofstream打开的文件中已有数据的唯一方法就是显示的指定文件模式为in或app模式。<br>每次调用open时都会确定文件模式，对于一个给定的流，每次打开文件时都可以改变其文件模式，例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream <span class="keyword">out</span>;   <span class="comment">//未指定文件打开模式</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">open</span>(<span class="string">"file"</span>);  <span class="comment">//默认文件out隐含截断</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">close</span>();</span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">open</span>(<span class="string">"file1"</span>,ofstream::<span class="keyword">app</span>);  <span class="comment">//模式为输出和追加</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<p>通常情况下，out模式即意味着同时使用trunc模式，文件内容将被清空，打开file1文件时，指定了append模式，文件中已有的数据将会得到保留，所有写操作都会在文件末尾进行。</p>
<h1 id="一、管理输出缓冲-1">一、管理输出缓冲</h1><p>每个输出流都会管理一个输出缓冲区，用来保存程序读写的数据。比如：<br>cout&lt;&lt;Please input a number&lt;&lt;endl;<br>这样文本串可能被立即打印出来，也可能先被操作系统保存到缓冲区，然后再打印。设备的写操作可能是费时的，这样，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作或者单一的设备写操作可带来性能上的很大提升。<br>  下面总结了导致缓冲刷新的原因：</p>
<ol>
<li><p>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。</p>
</li>
<li><p>缓冲区满时需要刷新缓冲区之后新的数据才能被继续写入。</p>
</li>
<li><p>操纵符endl可以显示刷新缓冲区</p>
</li>
<li><p>在每个输出操作之后，可用操纵符unitbuf设置流的内部状态来清空缓冲区。默认情况下对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</p>
</li>
<li><p>一个输出流可能被关联到另一个流。此时，当读写被关联的流时，关联到的流的缓冲区会被刷新。比如，默认情况下cin和cerr都关联到cout，因此，读cin或写cerr都会导致cout的缓冲区被刷新。</p>
</li>
</ol>
<hr>
<h1 id="二、刷新输出缓冲区-1">二、刷新输出缓冲区</h1><p>使用操纵符endl可以刷新缓冲区并完成换行工作。类似的flush也能刷新缓冲区，但不输出任何额外字符，不像endl那样还会换行。ends则是向缓冲区插入一个空字符，然后刷新缓冲区。他们的用法和endl一样。</p>
<p>如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操纵符来设置流的内部状态清空缓冲区。它告诉流在接下来的每次输出写操作之后都进行一次flush操作，而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<p>cout&lt;&lt;unitbuf;  //现在所有输出操作后都会立即刷新缓冲区<br>cout&lt;&lt;nounitbuf;  //恢复正常的缓冲方式<br>注：如果程序崩溃，输出缓冲区不会被刷新，所有输出数据很可能停留在输出缓冲区等待打印。<br>另外，当输入流被关联到输出流，那么一旦从输入流读取数据，都会先刷新关联的输出流。标准库将cout和cin关联在一起。</p>
<p>所以当执行：</p>
<p>cin&gt;&gt;ival;</p>
<p>时，将导致cout的缓冲区被刷新。这在交互式系统通常应该关联输入流和输出流。即所有输出和用户提示信息都会在读操作之前被打印出来。说道关联输入和输出流，就要说道tie函数，它有两个版本，一个不带参数，返回指向输出流的指针，如果本对象当前关联到一个输出流，则返回这个输出流的指针，如过对象没有关联到流返回空指针。tie还一个版本接受一个指向ostream的指针，将自己关联到次ostream。比如 x.tie(&amp;o)即将流x关联到输出流o 。（&amp;o  这里是对输出流对象o取址）。我们可以将一个istream对象关联到一个ostream对象也可以将一个ostream对象关联到另一个ostream对象。</p>
<p>cin.tie(&amp;cout);  //标准库中的将cin和cout关联在一起<br>如果想解开流的关联，可以将对象tie到一个空指针上，比如：<br>ostearm *old_tie=cin.tie(nullptr);  //cin不再与其他流关联</p>
<hr>
<h1 id="三、文件的输入输出-1">三、文件的输入输出</h1><h2 id="a-_IO-1">a. IO</h2><p>头文件fstrem中定义了三个支持文件IO</p>
<ol>
<li><p>ifstream 从给定文件读取数据</p>
</li>
<li><p>ofstream 向给定文件写入数据</p>
</li>
<li><p>fstream 读写给定文件</p>
</li>
</ol>
<p>fstream继承自iostream，所以诸如IO运算符&lt;&lt;  &gt;&gt; cin cout getline等都能适用，另外它还有些新成员来管理与流关联的文件。当然这些时fstream中特有的，可以对fstream ifstream ofstream对象调用。总结如下</p>
<ol>
<li><p>fstream  fstrm;       创建一个未绑定的流，fstream是头文件fstream中定义的一个类型</p>
</li>
<li><p>fstream fstrm(s);   c创建一个fstream，并打开名为s的文件，s可是string类型或是一个指向C风格的字符串指针，这些构造函数是explict的</p>
</li>
<li><p>fstream fstrm(s,mode)  和以上一样，按指定的mode打开文件</p>
</li>
</ol>
<p>fstrm.open(s)    打开名为s的文件，将文件与fstrm绑定，返回void</p>
<p>fstrm.close()    关闭与fstrm绑定的文件，返回void</p>
<p>fstrm.is_open()  返回一个bool值，指出绑定文件是否打开</p>
<h2 id="b-使用文件流对象-1">b.使用文件流对象</h2><p>  当有需要读写一个文件时，我们可先定义一个文件流对象，并将对象与文件关联绑定。创建文件流对象时，我们可提供文件名（选用），如果提供了文件名open成员函数会被自动调用，比如：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream <span class="keyword">in</span>(ifile);  <span class="comment">//构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream <span class="keyword">out</span>;    <span class="comment">//这是一个输出文件流但还未关联到任何文件</span></span><br></pre></td></tr></table></figure>
<p>我们已经知道，通常我们可以将一个派生类对象当做基类对象使用，因此，在需要iostream类型引用或指针的地方，我们也可用对应的fstream来调用。例如，假定输入输出文件名是通过传递给main函数的参数来指定，可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;  <span class="comment">//打开文件，建立一个文件输入流对象input</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;   <span class="comment">//打开输出文件，建立一个文件输出流对象output</span></span><br></pre></td></tr></table></figure>
<p>再举一例：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream <span class="keyword">in</span>(ifile);  <span class="comment">//构建一个ifstream并打开给定文件</span></span><br><span class="line">ofstream <span class="keyword">out</span>;   <span class="comment">//构建了一个输出文件流，但没有与任何文件绑定</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">open</span>(ifile+<span class="string">".copy"</span>);  将流对象绑定指定文件并打开</span><br></pre></td></tr></table></figure>
<p>像这里要是open失败了，failbit会被置位，调用open是有可能失败的，因为调用open时对它进行检测通常是一个好习惯，它和cin用作条件类似，open要是失败，条件会为假，就不会去使用out流了。比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(out)</span></span>   <span class="comment">//检查open是否成功，成功了，就可以使用文件了</span></span><br></pre></td></tr></table></figure>
<p>一旦文件流打开，它就保持了与对应文件的关联，对一个已打开的文件流调用open会失败，并导致failbit被置位。随后任何试图使用文件流的操作都会失败。这和socket 、serial等一样啊。如果你想改变文件流关联的对象，那么必须先关闭当前已关联的文件，关闭成功后再去关联或者打开新的文件，比如：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">in</span>.<span class="built_in">close</span>();          <span class="comment"> //关闭当前关联的文件</span></span><br><span class="line"><span class="operator">in</span>.<span class="built_in">open</span>(ifile+<span class="string">"2"</span>);  打开另一个文件</span><br></pre></td></tr></table></figure>
<p>一旦open成功，则open会设置流的状态，使得good()为true</p>
<h2 id="c-自动构造和析构-1">c.自动构造和析构</h2><p> 任务：由main函数接受要处理的一个文件列表，考虑用循环的方式解决问题，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(quto p=argv+<span class="number">1</span>:p!=argv+argc;++p)&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>;  <span class="comment">//创建文件输出流并打开文件</span></span><br><span class="line">  <span class="keyword">if</span>(input)&#123;         <span class="comment">//如果创建成功，处理文件</span></span><br><span class="line">      process(input);</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">      <span class="built_in">cerr</span>&lt;&lt;<span class="string">"couldn't open: "</span>&lt;&lt;<span class="built_in">string</span>(*p);</span><br><span class="line">&#125;  <span class="comment">//每次循环后创建的input流对象会离开作用域，自动销毁</span></span><br></pre></td></tr></table></figure>
<p>上面流对象在每次循环中都将被重新创建和销毁，当一个流对象离开其作用域时，与之关联的文件会自动关闭，即close会被自动调用。 </p>
<hr>
<h1 id="四、文件模式-1">四、文件模式</h1><p>  文件被open时会涉及文件模式，它指出如何来使用文件，总结如下；</p>
<ol>
<li>in  以读的方式打开文件 </li>
<li><p>out  以写得方式打开文件</p>
</li>
<li><p>app  每次写操作前均定为到文件末尾</p>
</li>
<li><p>ate  打开文件后立即定为到文件末尾</p>
</li>
<li><p>trunc  截断文件</p>
</li>
<li><p>binary  以二进制方式进行IO<br>相关原则如下：</p>
</li>
<li><p>只能对ofstream或fstream对象设定out模式</p>
</li>
<li><p>只能对ifstrem或fstream对象设定in模式</p>
</li>
<li><p>只有当out也被设定时才能设定trunc模式</p>
</li>
<li><p>只要trunc没被设定，就可以设定app模式，在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开</p>
</li>
<li><p>默认情况，即使没有指定trunc，以out模式打开的文件也会被截断，为了保留以out模式打开的文件的内容，必须同时指定app模式，这样只会将数据追加写到文件末尾，或者同时指定in模式，即打开文件同时进行读写操作</p>
</li>
<li><p>每个文件流类型都定义了一个默认的文件模式，总结如下：</p>
</li>
</ol>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream——<span class="keyword">in</span>模式                         ofstream——<span class="keyword">out</span>模式</span><br><span class="line"></span><br><span class="line">fstream—— <span class="keyword">in</span> 和 <span class="keyword">out</span>模式</span><br></pre></td></tr></table></figure>
<p>需要说明的是以out模式打开文件会丢弃已有的数据，默认情况下，打开一个ofstream时文件的内容会被丢弃，然而阻止这一清空给定文件的好办法就是打开的同时指定app模式。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下语句，file会被截断</span></span><br><span class="line">ofstream <span class="keyword">out</span>(<span class="string">"file1"</span>);  <span class="comment">//隐含以输出模式打开文件并截断文件</span></span><br><span class="line">ofstream <span class="keyword">out</span><span class="number">2</span>(<span class="string">"file1"</span>,ofstream::<span class="keyword">out</span>); <span class="comment">//隐含地截断文件</span></span><br><span class="line">ofstream <span class="keyword">out</span><span class="number">3</span>(<span class="string">"file1"</span>,ofstream::<span class="keyword">out</span> | ofstream::trunc)</span><br><span class="line"><span class="comment">//为了保留文件内容，我们必须显示指定app模式</span></span><br><span class="line">ofstream <span class="keyword">out</span>(<span class="string">"file"</span>,ofstream::app);  <span class="comment">//隐含为输出模式</span></span><br><span class="line">ofstream <span class="keyword">out</span><span class="number">2</span>(<span class="string">"file"</span>,ofstream::<span class="keyword">out</span> | ofstream::app);</span><br></pre></td></tr></table></figure>
<p>总结：要想保留被ofstream打开的文件中已有数据的唯一方法就是显示的指定文件模式为in或app模式。<br>每次调用open时都会确定文件模式，对于一个给定的流，每次打开文件时都可以改变其文件模式，例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream <span class="keyword">out</span>;   <span class="comment">//未指定文件打开模式</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">open</span>(<span class="string">"file"</span>);  <span class="comment">//默认文件out隐含截断</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">close</span>();</span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">open</span>(<span class="string">"file1"</span>,ofstream::<span class="keyword">app</span>);  <span class="comment">//模式为输出和追加</span></span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<p>通常情况下，out模式即意味着同时使用trunc模式，文件内容将被清空，打开file1文件时，指定了append模式，文件中已有的数据将会得到保留，所有写操作都会在文件末尾进行。</p>
<h1 id="一、string流简述">一、string流简述</h1><p>前面我们已经说道，标准库中定义IO类型的有三个头文件：iostream 定义； 用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。其中在sstring头文件中定义了三个类型来支持内存IO，这些类型可以向string中写入数据，从string读取数据，就像string是一个IO流一样。</p>
<p>相关列出如下：</p>
<ol>
<li><p>istringstream 从string读取数据。</p>
</li>
<li><p>ostringstream 向string写入数据。</p>
</li>
<li><p>stringstream 既可从string读取数据也可向string写数据。</p>
</li>
</ol>
<p>和前面fstream一样，sstream也是继承自iostream，另外也有些新的东西假如，总结如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">sstream</span> <span class="keyword">strm; </span>       //<span class="keyword">strm是一个未绑定的stringstream对</span><br><span class="line"></span><span class="label">sstream</span> <span class="keyword">strm(s); </span>    //<span class="keyword">strm是一个sstream对象，保存string </span>s的一个拷贝，此构造函数explicit</span><br><span class="line"><span class="keyword">strm.str(); </span>         //返回<span class="keyword">strm所保存的string的拷贝</span><br><span class="line"></span><span class="keyword">strm.str(s); </span>        //将<span class="keyword">string </span>s拷贝到<span class="keyword">strm中，返回void</span></span><br></pre></td></tr></table></figure>
<hr>
<p>二、使用istringstream</p>
<p>  当你想对整行文本进行处理，而其他一些工作时处理行内的单个单词时，通常使用istringstream。</p>
<p>  任务：假如有一个文件，列出了一些人和他们的电话号码，某些人只有一个号码，而某些人则有多个：家庭电话，工作电话，移动电话。输入文件可能是这样;</p>
<p>morgan  13332517100  </p>
<p>drew    13336547895  13335247654</p>
<p>jim     13336547126  13335647856 13335267865</p>
<p>即文件中每条记录都以一个人名开始，后面跟若干个电话号码，我们可以先定定义一个数据结构来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PersonInfo&#123;</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; phonses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  有了这样一个结构后，我们可以创建一个PersonInfo的vector。vector中的每个元素对应文件中的一条记录。我们可通过循环读取数据，每个循环读取一条记录，然后提取个人姓名和电话号码信息，实现如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="built_in">line</span>,<span class="built_in">word</span>; <span class="comment"> //分别用来保存来自输入的一行和单词</span></span><br><span class="line">vector&lt;PersonInfo&gt; people; <span class="comment"> //保存来自输入的所有记录</span></span><br><span class="line"><span class="keyword">while</span>(getline(cin,<span class="built_in">line</span>))&#123;     <span class="comment"> //逐行读取数据直到cin遇到文件尾或者其它错误</span></span><br><span class="line">  PersonInfo info; <span class="comment"> //创建一个保存一条数据记录的PersonInfo对象</span></span><br><span class="line">  istringstream record(<span class="built_in">line</span>); <span class="comment"> //将记录绑定到刚读入的行信息</span></span><br><span class="line">  <span class="keyword">while</span>(record&gt;&gt;<span class="built_in">word</span>) <span class="comment"> //读取电话号码</span></span><br><span class="line">      info.phones.push_back(<span class="built_in">word</span>); <span class="comment"> //保持它们</span></span><br><span class="line">  people.push_back(info); <span class="comment"> //将此记录追加到people末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里我们先用getline从标准输入读取整条记录（一行），然后将istringstream与该条记录进行绑定，现在我们就可以把该部分内存就像一个IO那样去使用它了，可实现在一个循环里，依次将数据读入构造一个PersonInfo对象，当string数据全部读出后，同样也会触发一个“文件结束”信号，退出循环，并将构造好的对象追加到vector中。</p>
<hr>
<h1 id="三、使用ostringstream">三、使用ostringstream</h1><p>  继续延续上面的例子，现在假如我们想逐个验证我们得到的用户电话号码并改变其输出格式：有效号码按规定输出到一个新文件，无效号码则是打印人名和无效号码的对应信息。因此，现在我们应该先针对每条记录先“写入”到一个内存ostringstream中，验证完所有电话号码后才进行输出操作。实现如下（程序中valid和format为假定已有的函数，分别完成电话号码的验证和改变格式的功能）：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entry:people)&#123;    <span class="comment">//对people中的每一项</span></span><br><span class="line">  ostringstream formatted,badNums;  <span class="comment">//每个循环步都创建的对象性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums:entry.phonse)&#123;  <span class="comment">//对每条记录中的电话号码</span></span><br><span class="line">    <span class="keyword">if</span>(!valid(nums))&#123;</span><br><span class="line">      badNums&lt;&lt;<span class="string">" "</span>&lt;&lt;nums;  <span class="comment">//将数的字符串形式存入badNums</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        formatted&lt;&lt;<span class="string">" "</span>&lt;&lt;format(nums);  <span class="comment">//将格式化的字符串“写入”formatted</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(badNums.str().empty())                       <span class="comment">//没有错误的数</span></span><br><span class="line">     os&lt;&lt;entry.name&lt;&lt;<span class="string">" "</span>&lt;&lt;formatted.str()&lt;&lt;endl;   <span class="comment">//打印名字和格式化的数</span></span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">//否则打印名字和错误的数</span></span><br><span class="line">     cerr&lt;&lt;<span class="string">"input error: "</span>&lt;&lt;entry.name</span><br><span class="line">         &lt;&lt;“ invalid number(s) <span class="string">"&lt;&lt;badNums.str()&lt;&lt;endl;</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="四、总结">四、总结</h1><p>  总结来说：</p>
<ol>
<li><p>iostream处理控制台IO</p>
</li>
<li><p>fstream 处理命名文件IO</p>
</li>
<li><p>stringstream完成内存string的IO</p>
</li>
</ol>
<p>后两者都继承自iostream，因此很大程度上都能执行一样的操作。</p>
<p>另外，每个IO对象都还会维护一组条件状态，用来指出此对象上是否可进行IO操作或者遇到什么样的错误，标准库中提供一组函数，可用来设置和检测这些状态。</p>
<p>一、格式化输入输出</p>
<p>  除了条件状态每个iostream对象还维护着格式状态控制IO的格式化细节。比如：整型值得进制、浮点值得精度、输出元素的宽度等。</p>
<p>1.1 用操纵符改变格式状态</p>
<p>  操纵符是一个函数或者对象，会影响流的状态，并能用作输入或输出运算符的运算对象。比如操纵符endl，我们可以将它“写”到输出流，就像它是一个值一样，但它不是一个普通的值，而是一个操作，用于输出一个换行符并刷新缓冲区。</p>
<p>  操纵符分为控制数值输出形式和控制补白数量和位置两大类。大多数改变格式状态的操纵符都是由 设置/复原 成对出现，其中复原是复原为默认格式。当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。建议是最好在不需要特殊格式的时候尽快将流恢复到默认状态。</p>
<p>1.1.1 控制布尔值的格式</p>
<p>  操纵符改变对象的格式状态的典型是用boolalpha操纵符控制布尔值的显示格式，默认下bool值打印为1（true）或0（false），我们可以对流使用boolalpha操纵符来覆盖这种格式。而操纵符noboolalpha则可以帮助恢复默认格式。测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"default bool values: "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; boolalpha </span><br><span class="line">     &lt;&lt;<span class="string">"aopha bool valuse: "</span> </span><br><span class="line">     &lt;&lt;<span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt;endl</span><br><span class="line">     &lt;&lt;<span class="string">"recover default bool values: "</span></span><br><span class="line">     &lt;&lt;noboolalpha                           <span class="comment">//通常情况下用完后恢复默认格式</span></span><br><span class="line">     &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="literal">false</span></span><br><span class="line">     &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.1.2 控制整型值得进制</p>
<p>  hex——十六进制输出</p>
<p>  oct——八进制输出</p>
<p>  dec——十进制 </p>
<p>这些操纵符的用法和endl等一样。但要注意的是这三个只影响整型运算对象，对浮点值不受影响。</p>
<p>1.1.3在输出中指出进制</p>
<p>  默认格式状态下，在打印数值时不会显示进制，这时可使用showbase操纵符，规范如下：</p>
<p>  前导 0x 表示十六进</p>
<p>  前导 0  表示八进制</p>
<p>  无前导表示十进制</p>
<p>而noshowbase则恢复流状态，不再显示整型值得进制。提到十六进制，就涉及字母的大小写，默认格式状态是小写，我们可以使用操纵符uppercase使得字母大写，对应的nouppercase可使得字母恢复小写模式。于是类似：</p>
<figure class="highlight"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  &#10;&#24120;&#29992;&#26469;&#20174;&#22823;&#20889;&#34920;&#31034;&#30340;&#21313;&#20845;&#36827;&#21046;&#24674;&#22797;&#21040;&#40664;&#35748;&#30340;&#21313;&#36827;&#21046;&#26684;&#24335;&#29366;&#24577;&#26174;&#31034;&#12290;&#10;&#10;&#10;1.1.4&#25511;&#21046;&#28014;&#28857;&#25968;&#26684;&#24335;&#10;&#10;  &#40664;&#35748;&#24773;&#20917;&#19979;&#65292;&#28014;&#28857;&#20540;&#25353;&#20845;&#20301;&#25968;&#23383;&#31934;&#24230;&#25171;&#21360;&#65292;&#22914;&#26524;&#27809;&#23567;&#25968;&#37096;&#20998;&#21017;&#19981;&#25171;&#21360;&#23567;&#25968;&#37096;&#20998;&#21253;&#25324;&#23567;&#25968;&#28857;&#65292;&#26681;&#25454;&#28014;&#28857;&#25968;&#30340;&#20540;&#36873;&#25321;&#25171;&#21360;&#25104;&#23450;&#28857;&#21313;&#36827;&#21046;&#25110;&#31185;&#23398;&#35745;&#25968;&#27861;&#24418;&#24335;&#65292;&#38750;&#24120;&#22823;&#25110;&#32773;&#38750;&#24120;&#23567;&#30340;&#20540;&#23558;&#25171;&#21360;&#25104;&#31185;&#23398;&#35745;&#25968;&#27861;&#65292;&#20854;&#20182;&#25171;&#21360;&#25104;&#23450;&#28857;&#21313;&#36827;&#21046;&#65292;&#20197;&#20445;&#35777;&#33391;&#22909;&#30340;&#21487;&#35835;&#24615;&#12290;&#10;&#10;  a.&#25351;&#23450;&#28014;&#28857;&#25968;&#25171;&#21360;&#31934;&#24230;&#10;&#10;  &#31934;&#24230;&#33021;&#25511;&#21046;&#25171;&#21360;&#30340;&#25968;&#23383;&#24635;&#25968;&#65292;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;&#35843;&#29992;IO&#23545;&#35937;&#30340;precision&#25104;&#21592;&#25110;&#20351;&#29992;setprecision&#25805;&#32437;&#31526;&#65288;&#23450;&#20041;&#22312;&#22836;&#25991;&#20214;iomanip&#20013;&#65289;&#26469;&#25913;&#21464;&#31934;&#24230;&#12290;precision&#25104;&#21592;&#20989;&#25968;&#26159;&#37325;&#36733;&#30340;&#65292;&#19968;&#20010;&#29256;&#26412;&#25509;&#21463;int&#20540;&#65292;&#33021;&#23558;&#31934;&#24230;&#35774;&#20026;&#35813;&#20540;&#65292;&#24182;&#36820;&#22238;&#26087;&#31934;&#24230;&#20540;&#65292;&#36824;&#19968;&#20010;&#29256;&#26412;&#19981;&#25509;&#21463;&#21442;&#25968;&#65292;&#36820;&#22238;&#24403;&#21069;&#31934;&#24230;&#20540;&#65292;setprecision&#25805;&#32437;&#31526;&#21017;&#25509;&#21463;&#19968;&#20010;&#21442;&#25968;&#29992;&#20110;&#35774;&#32622;&#31934;&#24230;&#12290;&#27979;&#35797;&#31243;&#24207;&#22914;&#19979;&#65306;</span><br></pre></td></tr></table></figure>
<p>#include<iostream></iostream></p>
<p>#include<iomanip><br>using namespace std;<br>int main(){<br>  cout &lt;&lt; “Default percision: “ &lt;&lt; cout.precision() &lt;&lt; “Value: “ &lt;&lt; sqrt(2) &lt;&lt; endl;<br>  cout &lt;&lt; “Set 12 percision with precision function: “ &lt;&lt; cout.precision(12) &lt;&lt; “ Value: “ &lt;&lt; sqrt(2)&lt;<endl; 3="" cout="" <<="" "set="" percision="" with="" setprecision:="" "="" setprecision(3)="" "value:="" sqrt(2)="" endl;="" }="" <figure="" class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一、指定浮点数计数法</span><br><span class="line"></span><br><span class="line">  最佳实践：除非你需要控制浮点数的表示形式，比如按列打印数据或打印表示金额或百分比的数据），否则由标准库选择计数法是最好的方式。</span><br><span class="line"></span><br><span class="line">  同样的道理，通过使用操纵符可以控制流使用科学计数法、定点十进制或十六进制计数。这些操纵符总结如下：</span><br><span class="line"></span><br><span class="line">  scientific 改变流的状态使用科学计数法</span><br><span class="line"></span><br><span class="line">  fixed         改变流的状态使用定点十进制</span><br><span class="line"></span><br><span class="line">  hexfloat  强制浮点数使用十六进制格式</span><br><span class="line"></span><br><span class="line">  defaultfloat 将流恢复到默认状态（根据要打印的值选择计数法）</span><br><span class="line"></span><br><span class="line">-<span class="ruby">--</span><br><span class="line"></span></span><br><span class="line"></span><br><span class="line">二、打印小数点</span><br><span class="line"></span><br><span class="line">  默认情况当浮点值得小数部分为0时不显示小数点，showpoint操纵符强制打印小数点；noshowpoint则恢复默认行为。比如：</span><br></pre></td></tr></table></endl;></iomanip></p>
<p>cout&lt;<showpoint<<10.0 <<noshowpoint<<endl;="" <figure="" class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby">---</span><br><span class="line"></span></span><br><span class="line">三、输出补白</span><br></pre></td></tr></table></showpoint<<10.0></p>
<p>setw  指定下一个数字或字符串值得最小空间，例：setw(12) 将在输出中至少流出12个位置供下一个输出占据</p>
<p>  left  左对齐输出</p>
<p>  right 右对齐输出，默认格式</p>
<p>  interal  控制负数的符号的位置，左边符号对齐，右对值对齐，用空格填满所有中间空间</p>
<p>setfii  允许指定一个字符代替默认的空格来补白输出。例：setfill(‘#’)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面在来总结下定义在头文件iomanip中的操纵符，有：</span><br></pre></td></tr></table></figure></p>
<p>setfill(ch)                            用字符ch填充空白</p>
<p>setprecision(n)                 将浮点精度设置为n</p>
<p>setw(w)                              读或者写值得宽度为w个字符</p>
<p>setbase(b)                         将整数输出为b进制<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby">---</span><br><span class="line"></span></span><br><span class="line">四、控制输入格式</span><br><span class="line"></span><br><span class="line">  默认情况下，输入运算符会忽略空白符（空格符、制表符、换行符、回车符）而操纵符noskipws则会令输入运算符读取空白符而不是跳过，恢复默认行为则再使用skipws操纵符，比如：</span><br></pre></td></tr></table></figure></p>
<p>char ch;<br>while(cin&gt;&gt;ch){<br>    cout&lt;<ch; <figure="" class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">循环执行 <span class="number">4</span>次</span><br></pre></td></tr></table></ch;></p>
<p>cin&gt;&gt;noshipws;  //现在设置cin读取空白符<br>while(cin&gt;&gt;ch)<br>  cout&lt;<ch; cin="">&gt;skipws;  //将cin恢复到默认状态，丢弃空白符<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和前一样用相同的输入时，循环会执行<span class="number">7</span>次（<span class="number">4</span>个普通字符，一个空格字符，一个制表符，一个回车符）</span><br><span class="line"></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"></span><br><span class="line"> 五、未格式化的输入/输出操作</span><br><span class="line"></span><br><span class="line">  未格式化IO操作运允许我们将一个流当做一个无解释的字节序列来处理。比如我们可以使用未格式化IO操作<span class="keyword">get</span>和<span class="keyword">put</span>来读取和写入一个字符:</span><br></pre></td></tr></table></figure></ch;></p>
<p>char ch;<br>while(cin.get(ch))<br>  cout.put(ch);<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这种未格式化的IO操作执行于底层操作之上，不会忽略任何字符。单字节底层IO操作总结如下：</span><br></pre></td></tr></table></figure></p>
<p>is.get(ch)        从istream is流中读取下一个字节存入字符ch中，返回is流</p>
<p>os.put(ch)        将字符ch输出到ostream os，返回os流</p>
<p>is.get()          将is流的下一个字节作为int返回</p>
<p>is.putback(ch)    将字符ch放回is流中，返回is</p>
<p>is.unget()        将is向后移动一个字节，返回is流</p>
<p>is.peek()         将下一个字节作为int返回，但不从流中删除它<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">六、将字符放回输入流</span><br><span class="line"></span><br><span class="line">  有三种方法：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> peek方法返回输入流中下一个字符的副本，但不会将它从流中删除，peek返回的值仍然在流中</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> unget使得输入流向后移动一个字节</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> putback退回从流中读取的最后一个值，接受一个参数，但此参数必须与最后读取的值相同</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">七、从输入操作返回的<span class="keyword">int</span>值</span><br><span class="line"></span><br><span class="line">  函数peek和无参的get都以<span class="keyword">int</span>类型从输入流返回一个字符。但为何不用<span class="keyword">char</span>显得更自然呢，原因是：返回<span class="keyword">int</span>可以返回文件尾标记，<span class="keyword">char</span>范围中的每个值表示一个真实字符，因此范围中没有额外的值可用来表示文件尾。返回<span class="keyword">int</span>的函数先将返回的字符转换为<span class="keyword">unsigned</span> <span class="keyword">char</span>，然后在将结果提升到<span class="keyword">int</span>。因此即使字符集中友字符映射到负值，这些操作返回的<span class="keyword">int</span>也是正值。而标准库使用负值表示文件尾，这样就可以保证与任何合法字符的值都不同。头文件cstdio定义了一个名为EOF的<span class="keyword">const</span>，可用来检测从get返回的值是否是文件尾，而不必记忆表示文件尾的实际数值。</span><br></pre></td></tr></table></figure></p>
<p>int ch;  //使用一个int而不是一个char来保存get()的返回值<br>while( (ch=cin.get() )!=EOF)<br>  cout.put(ch);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">  </span><br><span class="line">----</span></span><br><span class="line"></span><br><span class="line">八、多字节操作</span><br><span class="line"></span><br><span class="line"><span class="code">  如果速度是考虑的重点，那么使用未格式化IO操作一次处理大块数据是很有必要的。总结如下：</span></span><br><span class="line"></span><br><span class="line">is.get(sink,size,delim)</span><br><span class="line"></span><br><span class="line"><span class="code">  从is流中最多读取size个字节，并保存在字符数组中，字符数组的起始地址由sink给出，读取过程直至遇到字符delim或读取了size个字节或遇到文件尾时停止。如果遇到的是delim，则将其留在输入流中，不读取出来存入sink中。</span></span><br></pre></td></tr></table></figure></p>
<p>is.getline(sink,size,delim);           //和上述get类似<br>is.read(sink,size);                //读取最多size个字节，存入字符数组sink中，返回is流<br>is.gcount();               //返回上一个未格式化读取操作从is读取的字节数<br>os.write(source,size);     //将字符数组source中的size个字节写入os，返回os<br>is.ignore(size,delim);     //读取并忽略最多size个字符，包括delim，与其他未格式化函数不同，ignore有默认参数，size默认值为1,delim的默认值为文件尾。<br>get和getline有类似的行为，差别在于get将分隔符留作istream中的下一个字符，而getline则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在sink中。<br>```</p>
<hr>
<p>九、确定读取了多少个字符</p>
<p>某些操作从输入读取未知个数的字节，可以调用gcount来确定最后一个未格式化输入操作读取了多少个字符。将字符退回流的单字符操作也属于未格式化输入操作。如果在调用gcout之前调用了peek、unget或putback，则gcount的返回值为0 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、管理输出缓冲">一、管理输出缓冲</h1><p>每个输出流都会管理一个输出缓冲区，用来保存程序读写的数据。比如：<br>cout&lt;&lt;Please input a number&lt;&lt;endl;<br>这样文本串可能被立即打印出来，也可能先被操作系统保存到缓冲区，然后再打印。设备的写操作可能是费时的，这样，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作或者单一的设备写操作可带来性能上的很大提升。</p>]]>
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(转)1.一个简单的博客]]></title>
    <link href="http://yoursite.com/2015/09/17/(%E8%BD%AC)1.%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2015/09/17/(转)1.一个简单的博客/</id>
    <published>2015-09-17T10:19:26.000Z</published>
    <updated>2015-12-13T09:56:43.691Z</updated>
    <content type="html"><![CDATA[<h2 id="学习环境">学习环境</h2><p><strong>Node.js</strong> ： 0.10.32</p>
<p><strong>Express</strong> ： 4.10.2</p>
<p><strong>MongoDB</strong> ： 2.6.1</p>
<h2 id="快速开始">快速开始</h2><h3 id="安装_Express">安装 Express</h3><p>express 是 Node.js 上最流行的 Web 开发框架，正如他的名字一样，使用它我们可以快速的开发一个 Web 应用。我们用 express 来搭建我们的博客，打开命令行，输入：</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> express-generator</span>
</code></pre><p>安装 express 命令行工具，使用它我们可以初始化一个 express 项目。<br><a id="more"></a></p>
<h3 id="新建一个工程">新建一个工程</h3><p>在命令行中输入：</p>
<pre><code>$ express -e <span class="keyword">blog
</span>$ cd <span class="keyword">blog </span>&amp;&amp; npm install
</code></pre><p>初始化一个 express 项目并安装所需模块，如下图所示：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.1.jpg?raw=true" alt=""></p>
<p>然后运行：</p>
<pre><code><span class="variable">$ </span><span class="constant">DEBUG</span>=blog node ./bin/www
</code></pre><p>（上面的代码报错的话，可以这样运行启动项目：npm start）<br>启动项目，此时命令行中会显示 <strong>blog Express server listening on port 3000 +0ms</strong>，在浏览器里访问 <code>localhost:3000</code>，如下图所示：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.2.jpg?raw=true" alt=""></p>
<p>至此，我们用 express 初始化了一个工程项目，并指定使用 ejs 模板引擎，下一节我们讲解工程的内部结构。</p>
<h3 id="工程结构">工程结构</h3><p>我们回头看看生成的工程目录里面都有什么，打开我们的 blog 文件夹，里面如图所示：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.3.jpg?raw=true" alt=""></p>
<p><strong>app.js</strong>：启动文件，或者说入口文件<br><strong>package.json</strong>：存储着工程的信息及模块依赖，当在 dependencies 中添加依赖的模块时，运行 <code>npm install</code>，npm 会检查当前目录下的 package.json，并自动安装所有指定的模块<br><strong>node_modules</strong>：存放 package.json 中安装的模块，当你在 package.json 添加依赖的模块并安装后，存放在这个文件夹下<br><strong>public</strong>：存放 image、css、js 等文件<br><strong>routes</strong>：存放路由文件<br><strong>views</strong>：存放视图文件或者说模版文件<br><strong>bin</strong>：存放可执行文件</p>
<p>打开app.js,让我们看看里面究竟有什么:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> favicon = <span class="keyword">require</span>(<span class="string">'serve-favicon'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="keyword">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="keyword">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="keyword">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = <span class="keyword">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> users = <span class="keyword">require</span>(<span class="string">'./routes/users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment after placing your favicon in /public</span></span><br><span class="line"><span class="comment">//app.use(favicon(__dirname + '/public/favicon.ico'));</span></span><br><span class="line">app.<span class="keyword">use</span>(logger(<span class="string">'dev'</span>));</span><br><span class="line">app.<span class="keyword">use</span>(bodyParser.json());</span><br><span class="line">app.<span class="keyword">use</span>(bodyParser.urlencoded(&#123; extended: <span class="keyword">false</span> &#125;));</span><br><span class="line">app.<span class="keyword">use</span>(cookieParser());</span><br><span class="line">app.<span class="keyword">use</span>(express.<span class="keyword">static</span>(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(<span class="string">'/'</span>, routes);</span><br><span class="line">app.<span class="keyword">use</span>(<span class="string">'/users'</span>, users);</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch 404 and forward to error handler</span></span><br><span class="line">app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Not Found'</span>);</span><br><span class="line">    err.status = <span class="number">404</span>;</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error handlers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// development error handler</span></span><br><span class="line"><span class="comment">// will print stacktrace</span></span><br><span class="line"><span class="keyword">if</span> (app.get(<span class="string">'env'</span>) === <span class="string">'development'</span>) &#123;</span><br><span class="line">    app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span> </span>&#123;</span><br><span class="line">        res.status(err.status || <span class="number">500</span>);</span><br><span class="line">        res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">            message: err.message,</span><br><span class="line">            error: err</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production error handler</span></span><br><span class="line"><span class="comment">// no stacktraces leaked to user</span></span><br><span class="line">app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span> </span>&#123;</span><br><span class="line">    res.status(err.status || <span class="number">500</span>);</span><br><span class="line">    res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">        message: err.message,</span><br><span class="line">        error: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = app;</span><br></pre></td></tr></table></figure>
<p>这里我们通过require()加载了express、path 等模块,以及 routes 文件夹下的index. js和 users.js 路由文件。 下面来讲解每行代码的含义。</p>
<p>(1) var app = express()：生成一个express实例 app。<br>(2)app.set(‘views’, path.join(__dirname, ‘views’))：设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。<br>(3)app.set(‘view engine’, ‘ejs’)：设置视图模板引擎为 ejs。<br>(4)app.use(favicon(__dirname + ‘/public/favicon.ico’))：设置/public/favicon.ico为favicon图标。<br>(5)app.use(logger(‘dev’))：加载日志中间件。<br>(6)app.use(bodyParser.json())：加载解析json的中间件。<br>(7)app.use(bodyParser.urlencoded({ extended: false }))：加载解析urlencoded请求体的中间件。<br>(8)app.use(cookieParser())：加载解析cookie的中间件。<br>(9)app.use(express.static(path.join(__dirname, ‘public’)))：设置public文件夹为存放静态文件的目录。<br>(10)app.use(‘/‘, routes);和app.use(‘/users’, users)：路由控制器。<br>(11)</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">function</span>(req, res, <span class="keyword">next</span>) &#123;</span><br><span class="line">    var <span class="built_in">err</span> = <span class="keyword">new</span> <span class="keyword">Error</span>(<span class="comment">'Not Found');</span></span><br><span class="line">    <span class="built_in">err</span>.status = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">next</span>(<span class="built_in">err</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>捕获404错误，并转发到错误处理器。<br>(12)</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">app</span>.<span class="literal">get</span>('env') === 'development') &#123;</span><br><span class="line">    <span class="keyword">app</span>.<span class="keyword">use</span>(function(<span class="keyword">err</span>, req, res, next) &#123;</span><br><span class="line">        res.status(<span class="keyword">err</span>.status || 500);</span><br><span class="line">        res.render('<span class="keyword">error</span>', &#123;</span><br><span class="line">            message: <span class="keyword">err</span>.message,</span><br><span class="line">            <span class="keyword">error</span>: <span class="keyword">err</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发环境下的错误处理器，将错误信息渲染error模版并显示到浏览器中。<br>(13)</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>(function(<span class="keyword">err</span>, req, res, next) &#123;</span><br><span class="line">    res.status(<span class="keyword">err</span>.status || 500);</span><br><span class="line">    res.render('<span class="keyword">error</span>', &#123;</span><br><span class="line">        message: <span class="keyword">err</span>.message,</span><br><span class="line">        <span class="keyword">error</span>: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>生产环境下的错误处理器，将错误信息渲染error模版并显示到浏览器中。<br>(14)module.exports = app ：导出app实例供其他模块调用。</p>
<p>我们再看 bin/www 文件：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">var</span> debug = <span class="keyword">require</span>(<span class="string">'debug'</span>)(<span class="string">'blog'</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'port'</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(app.get(<span class="string">'port'</span>), <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  debug(<span class="string">'Express server listening on port '</span> + server.address().port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>(1)#!/usr/bin/env node：表明是 node 可执行文件。<br>(2)var debug = require(‘debug’)(‘blog’)：引入debug模块，打印调试日志。<br>(3)var app = require(‘../app’)：引入我们上面导出的app实例。<br>(4)app.set(‘port’, process.env.PORT || 3000)：设置端口号。<br>(5)</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = app.listen(app.<span class="keyword">get</span>(<span class="string">'port'</span>), <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  debug(<span class="string">'Express server listening on port '</span> + server.address().port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>启动工程并监听3000端口，成功后打印 Express server listening on port 3000。</p>
<p>我们再看 routes/index.js 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; title: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<p>生成一个路由实例用来捕获访问主页的GET请求，导出这个路由并在app.js中通过app.use(‘/‘, routes); 加载。这样，当访问主页时，就会调用res.render(‘index’, { title: ‘Express’ });渲染views/index.ejs模版并显示到浏览器中。</p>
<p>我们再看看 views/index.ejs 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'stylesheet'</span> <span class="attribute">href</span>=<span class="value">'/stylesheets/style.css'</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Welcome to <span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在渲染模板时我们传入了一个变量 title 值为 express  字符串，模板引擎会将所有 &lt;%= title %&gt; 替换为 express ，然后将渲染后生成的html显示到浏览器中，如上图所示。</p>
<p>在这一小节我们学习了如何创建一个工程并启动它，了解了工程的大体结构和运作流程，下一小节我们将学习 express 的基本使用及路由控制。</p>
<h2 id="路由控制">路由控制</h2><h3 id="工作原理">工作原理</h3><p>routes/index.js 中有以下代码：</p>
<pre><code><span class="tag">router</span><span class="class">.get</span>(<span class="string">'/'</span>, <span class="function">function</span>(req, res){
  <span class="tag">res</span><span class="class">.render</span>(<span class="string">'index'</span>, { <span class="attribute">title</span>: <span class="string">'Express'</span> });
});
</code></pre><p>这段代码的意思是当访问主页时，调用 ejs 模板引擎，来渲染 index.ejs 模版文件（即将 title 变量全部替换为字符串 Express），生成静态页面并显示在浏览器中。 </p>
<p>我们来作一些修改，以上代码实现了路由的功能，我们当然可以不要 routes/index.js 文件，把实现路由功能的代码都放在 app.js 里，但随着时间的推移 app.js 会变得臃肿难以维护，这也违背了代码模块化的思想，所以我们把实现路由功能的代码都放在 routes/index.js 里。官方给出的写法是在 app.js 中实现了简单的路由分配，然后再去 index.js 中找到对应的路由函数，最终实现路由功能。我们不妨把路由控制器和实现路由功能的函数都放到 index.js 里，app.js 中只有一个总的路由接口。</p>
<p>最终将 app.js 修改为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> favicon = <span class="keyword">require</span>(<span class="string">'serve-favicon'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="keyword">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="keyword">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="keyword">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = <span class="keyword">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'port'</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//app.use(favicon(__dirname + '/public/favicon.ico'));</span></span><br><span class="line">app.<span class="keyword">use</span>(logger(<span class="string">'dev'</span>));</span><br><span class="line">app.<span class="keyword">use</span>(bodyParser.json());</span><br><span class="line">app.<span class="keyword">use</span>(bodyParser.urlencoded(&#123; extended: <span class="keyword">true</span> &#125;));</span><br><span class="line">app.<span class="keyword">use</span>(cookieParser());</span><br><span class="line">app.<span class="keyword">use</span>(express.<span class="keyword">static</span>(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">routes(app);</span><br><span class="line"></span><br><span class="line">app.listen(app.get(<span class="string">'port'</span>), <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  console.log(<span class="string">'Express server listening on port '</span> + app.get(<span class="string">'port'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改 index.js 如下：</p>
<pre><code>module.exports = <span class="function"><span class="keyword">function</span><span class="params">(app)</span> </span>{
  app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'index'</span>, { title: <span class="string">'Express'</span> });
  });
};
</code></pre><p>现在，再运行你的 app，你会发现主页毫无二致。这里我们在 routes/index.js 中通过 <code>module.exports</code> 导出了一个函数接口，在 app.js 中通过 <code>require</code> 加载了 index.js 然后通过 <code>routes(app)</code> 调用了 index.js 导出的函数。</p>
<h3 id="路由规则">路由规则</h3><p>express 封装了多种 http 请求方式，我们主要只使用 <code>get</code> 和 <code>post</code> 两种，即 <code>app.get()</code> 和 <code>app.post()</code> 。</p>
<p><code>app.get()</code> 和 <code>app.post()</code> 的第一个参数都为请求的路径，第二个参数为处理请求的回调函数，回调函数有两个参数分别是 req 和 res，代表请求信息和响应信息 。路径请求及对应的获取路径有以下几种形式：  </p>
<p><strong>req.query</strong>  </p>
<pre><code><span class="comment">// GET /search?q=tobi+ferret  </span>
req<span class="class">.query</span><span class="class">.q</span>  
<span class="comment">// =&gt; "tobi ferret"  </span>

<span class="comment">// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse  </span>
req<span class="class">.query</span><span class="class">.order</span>  
<span class="comment">// =&gt; "desc"  </span>

req<span class="class">.query</span><span class="class">.shoe</span><span class="class">.color</span>  
<span class="comment">// =&gt; "blue"  </span>

req<span class="class">.query</span><span class="class">.shoe</span><span class="class">.type</span>  
<span class="comment">// =&gt; "converse"  </span>
</code></pre><p><strong>req.body</strong>  </p>
<pre><code><span class="comment">// POST user[name]=tobi&amp;user[email]=tobi@learnboost.com  </span>
req<span class="class">.body</span><span class="class">.user</span><span class="class">.name</span>  
<span class="comment">// =&gt; "tobi"  </span>

req<span class="class">.body</span><span class="class">.user</span><span class="class">.email</span>  
<span class="comment">// =&gt; "tobi@learnboost.com"  </span>

<span class="comment">// POST { "name": "tobi" }  </span>
req<span class="class">.body</span><span class="class">.name</span>  
<span class="comment">// =&gt; "tobi"  </span>
</code></pre><p><strong>req.params</strong></p>
<pre><code><span class="comment">// GET /user/tj  </span>
req<span class="class">.params</span><span class="class">.name</span>  
<span class="comment">// =&gt; "tj"  </span>

<span class="comment">// GET /file/javascripts/jquery.js  </span>
req<span class="class">.params</span>[<span class="number">0</span>]  
<span class="comment">// =&gt; "javascripts/jquery.js"  </span>
</code></pre><p><strong>req.param(name)</strong></p>
<pre><code><span class="comment">// ?name=tobi  </span>
req.<span class="function"><span class="title">param</span><span class="params">(<span class="string">'name'</span>)</span></span>  
<span class="comment">// =&gt; "tobi"  </span>

<span class="comment">// POST name=tobi  </span>
req.<span class="function"><span class="title">param</span><span class="params">(<span class="string">'name'</span>)</span></span>  
<span class="comment">// =&gt; "tobi"  </span>

<span class="comment">// /user/tobi for /user/:name   </span>
req.<span class="function"><span class="title">param</span><span class="params">(<span class="string">'name'</span>)</span></span>  
<span class="comment">// =&gt; "tobi"  </span>
</code></pre><p>不难看出：</p>
<ul>
<li><code>req.query</code>： 处理 get 请求，获取 get 请求参数</li>
<li><code>req.params</code>： 处理 /:xxx 形式的 get 或 post 请求，获取请求参数</li>
<li><code>req.body</code>： 处理 post 请求，获取 post 请求体</li>
<li><code>req.param()</code>： 处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query  </li>
</ul>
<p>路径规则还支持正则表达式，更多请查阅 <a href="http://expressjs.com/api.html" target="_blank" rel="external">Express 官方文档</a> 。</p>
<h3 id="添加路由规则">添加路由规则</h3><p>当我们访问 localhost:3000 时，会显示： </p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.2.jpg?raw=true" alt=""></p>
<p>当我们访问 localhost:3000/nswbmw 这种不存在的页面时就会显示： </p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.4.jpg?raw=true" alt=""></p>
<p>这是因为不存在 <code>/nswbmw</code> 的路由规则，而且它也不是一个 public 目录下的文件，所以 express 返回了 404 Not Found 的错误。下面我们来添加这条路由规则，使得当访问 localhost:3000/nswbmw 时，页面显示 hello,world!  </p>
<p><strong>注意</strong>：以下修改仅用于测试，看到效果后再把代码还原回来。</p>
<p>修改 index.js，在 <code>app.get(&#39;/&#39;)</code> 函数后添加一条路由规则：  </p>
<pre><code>app.<span class="keyword">get</span>(<span class="string">'/nswbmw'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  res.send(<span class="string">'hello,world!'</span>);
});
</code></pre><p>重启之后，访问 localhost:3000/nswbmw 页面显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.5.jpg?raw=true" alt=""></p>
<p>很简单吧？这一节我们学习了基本的路由规则及如何添加一条路由规则，下一节我们将学习模板引擎的知识。</p>
<h2 id="模版引擎">模版引擎</h2><h3 id="什么是模板引擎">什么是模板引擎</h3><p>模板引擎（Template Engine）是一个将页面模板和要显示的数据结合起来生成 HTML 页面的工具。<br>如果说上面讲到的 express 中的路由控制方法相当于 MVC 中的控制器的话，那模板引擎就相当于 MVC 中的视图。</p>
<blockquote>
<p>模板引擎的功能是将页面模板和要显示的数据结合起来生成 HTML 页面。它既可以运<br>行在服务器端又可以运行在客户端，大多数时候它都在服务器端直接被解析为 HTML，解析完成后再传输给客户端，因此客户端甚至无法判断页面是否是模板引擎生成的。有时候模板引擎也可以运行在客户端，即浏览器中，典型的代表就是 XSLT，它以 XML 为输入，在客户端生成 HTML 页面。但是由于浏览器兼容性问题，XSLT 并不是很流行。目前的主流还是由服务器运行模板引擎。</p>
<p>在 MVC 架构中，模板引擎包含在服务器端。控制器得到用户请求后，从模型获取数据，调用模板引擎。模板引擎以数据和页面模板为输入，生成 HTML 页面，然后返回给控制器，由控制器交回客户端。 </p>
<p align="right">——《Node.js开发指南》</p>

</blockquote>
<p><strong>什么是 ejs ?</strong></p>
<p>ejs 是模板引擎的一种，也是我们这个教程中使用的模板引擎，因为它使用起来十分简单，而且与 express 集成良好。</p>
<h3 id="使用模板引擎">使用模板引擎</h3><p>前面我们通过以下两行代码设置了模板文件的存储位置和使用的模板引擎：</p>
<pre><code>app.<span class="keyword">set</span>(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);
app.<span class="keyword">set</span>(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);
</code></pre><p><strong>注意</strong>：我们通过 <code>express -e blog</code> 只是初始化了一个使用 ejs 模板引擎的工程而已，比如 node_modules 下添加了 ejs 模块，views 文件夹下有 index.ejs 。并不是说强制该工程只能使用 ejs 不能使用其他的模板引擎比如 jade，真正指定使用哪个模板引擎的是 <code>app.set(&#39;view engine&#39;, &#39;ejs&#39;);</code> 。</p>
<p>在 routes/index.js 中通过调用 <code>res.render()</code> 渲染模版，并将其产生的页面直接返回给客户端。它接受两个参数，第一个是模板的名称，即 views 目录下的模板文件名，扩展名 .ejs 可选。第二个参数是传递给模板的数据对象，用于模板翻译。</p>
<p>打开 views/index.ejs ，内容如下：</p>
<p><strong>index.ejs</strong> </p>
<pre><code><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'stylesheet'</span> <span class="attribute">href</span>=<span class="value">'/stylesheets/style.css'</span> /&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Welcome to <span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>当我们 <code>res.render(&#39;index&#39;, { title: &#39;Express&#39; });</code> 时，模板引擎会把 &lt;%= title %&gt; 替换成 Express，然后把替换后的页面显示给用户。  </p>
<p>渲染后生成的页面代码为：</p>
<pre><code><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Express<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'stylesheet'</span> <span class="attribute">href</span>=<span class="value">'/stylesheets/style.css'</span> /&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Express<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Welcome to Express<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p><strong>注意</strong>：我们通过 <code>app.use(express.static(path.join(__dirname, &#39;public&#39;)))</code> 设置了静态文件目录为 public 文件夹，所以上面代码中的 <code>href=&#39;/stylesheets/style.css&#39;</code> 就相当于 <code>href=&#39;public/stylesheets/style.css&#39;</code> 。 </p>
<p>ejs 的标签系统非常简单，它只有以下三种标签： </p>
<ul>
<li>&lt;% code %&gt;：JavaScript 代码。  </li>
<li>&lt;%= code %&gt;：显示替换过 HTML 特殊字符的内容。  </li>
<li>&lt;%- code %&gt;：显示原始 HTML 内容。  </li>
</ul>
<p><strong>注意</strong>： <code>&lt;%= code %&gt;</code> 和 <code>&lt;%- code %&gt;</code> 的区别，当变量 code 为普通字符串时，两者没有区别。当 code 比如为 <code>&lt;h1&gt;hello&lt;/h1&gt;</code> 这种字符串时，<code>&lt;%= code %&gt;</code> 会原样输出 <code>&lt;h1&gt;hello&lt;/h1&gt;</code>，而 <code>&lt;%- code %&gt;</code> 则会显示 H1 大的 hello 字符串。  </p>
<p>我们可以在 <code>&lt;%  %&gt;</code> 内使用 JavaScript 代码。下面是 ejs 的官方示例：  </p>
<p><strong>The Data</strong>  </p>
<pre><code><span class="rule"><span class="attribute">supplies</span>:<span class="value"> [<span class="string">'mop'</span>, <span class="string">'broom'</span>, <span class="string">'duster'</span>]</span></span>
</code></pre><p><strong>The Template</strong></p>
<pre><code>&lt;ul&gt;
&lt;<span class="preprocessor">%</span> for<span class="comment">(var i=0; i&lt;supplies.length; i++)</span> {<span class="preprocessor">%</span>&gt;
   &lt;li&gt;&lt;<span class="preprocessor">%</span>= supplies[i] <span class="preprocessor">%</span>&gt;&lt;/li&gt;
&lt;<span class="preprocessor">%</span> } <span class="preprocessor">%</span>&gt;
&lt;/ul&gt;
</code></pre><p><strong>The Result</strong></p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>mop<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>broom<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>duster<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>我们可以用上述三种标签实现页面模板系统能实现的任何内容。</p>
<h3 id="页面布局">页面布局</h3><p>这里我们不使用layout进行页面布局，而是使用更为简单灵活的include。include 的简单使用如下：  </p>
<p><strong>index.ejs</strong></p>
<pre><code><span class="xml"></span>&lt;%-<span class="ruby"> <span class="keyword">include</span> a </span>%&gt;<span class="xml">
hello,world!
</span>&lt;%-<span class="ruby"> <span class="keyword">include</span> b </span>%&gt;<span class="xml"></span>
</code></pre><p><strong>a.ejs</strong></p>
<pre><code><span class="keyword">this</span> <span class="keyword">is</span> a.ejs
</code></pre><p><strong>b.ejs</strong></p>
<pre><code><span class="keyword">this</span> <span class="keyword">is</span> b.ejs
</code></pre><p>最终 index.ejs 会显示：</p>
<pre><code>this is <span class="tag">a</span><span class="class">.ejs</span>
hello,world!
this is <span class="tag">b</span>.ejs
</code></pre><p>这一节我们学习了模版引擎的相关知识，下一节我们正式开始学习如何从头开始搭建一个多人博客。</p>
<h2 id="搭建多人博客">搭建多人博客</h2><h3 id="功能分析">功能分析</h3><p>搭建一个简单的具有多人注册、登录、发表文章、登出功能的博客。  </p>
<h3 id="设计目标">设计目标</h3><p>未登录：主页左侧导航显示 home、login、register，右侧显示已发表的文章、发表日期及作者。<br>登陆后：主页左侧导航显示 home、post、logout，右侧显示已发表的文章、发表日期及作者。<br>用户登录、注册、发表成功以及登出后都返回到主页。  </p>
<p><strong>未登录</strong>：</p>
<p>主页：  </p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.6.jpg?raw=true" alt=""></p>
<p>登录页：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.7.jpg?raw=true" alt=""></p>
<p>注册页：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.8.jpg?raw=true" alt=""></p>
<p><strong>登录后</strong>：</p>
<p>主页:</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.9.jpg?raw=true" alt=""></p>
<p>发表页：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.10.jpg?raw=true" alt=""></p>
<p><strong>注意</strong>：没有登出页，当点击 LOGOUT 后，退出登陆并返回到主页。</p>
<h3 id="路由规划">路由规划</h3><p>我们已经把设计的构想图贴出来了，接下来的任务就是完成路由规划了。路由规划，或者说控制器规划是整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂，所以应该优先考虑。</p>
<p>根据构思的设计图，我们作以下路由规划：  </p>
<pre><code>/ ：首页
/login ：用户登录
/<span class="keyword">reg</span> ：用户注册
/<span class="keyword">post</span> ：发表文章
/logout ：登出
</code></pre><p>我们要求 <code>/login</code> 和 <code>/reg</code> 只能是未登录的用户访问，而 <code>/post</code> 和 <code>/logout</code> 只能是已登录的用户访问。左侧导航列表则针对已登录和未登录的用户显示不同的内容。 </p>
<p>修改 index.js 如下：  </p>
<pre><code>module.exports = <span class="function"><span class="keyword">function</span><span class="params">(app)</span> </span>{
  app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'index'</span>, { title: <span class="string">'主页'</span> });
  });
  app.<span class="keyword">get</span>(<span class="string">'/reg'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'reg'</span>, { title: <span class="string">'注册'</span> });
  });
  app.post(<span class="string">'/reg'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  });
  app.<span class="keyword">get</span>(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'login'</span>, { title: <span class="string">'登录'</span> });
  });
  app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  });
  app.<span class="keyword">get</span>(<span class="string">'/post'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'post'</span>, { title: <span class="string">'发表'</span> });
  });
  app.post(<span class="string">'/post'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  });
  app.<span class="keyword">get</span>(<span class="string">'/logout'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  });
};
</code></pre><p>如何针对已登录和未登录的用户显示不同的内容呢？或者说如何判断用户是否已经登陆了呢？进一步说如何记住用户的登录状态呢？我们通过引入会话（session）机制记录用户登录状态，还要访问数据库来保存和读取用户信息。下一节我们将学习如何使用数据库。</p>
<h2 id="使用数据库">使用数据库</h2><h3 id="MongoDB简介">MongoDB简介</h3><p>MongoDB 是一个基于分布式文件存储的 NoSQL（非关系型数据库）的一种，由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 支持的数据结构非常松散，是类似 json 的 bjson 格式，因此可以存储比较复杂的数据类型。MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
<p>MongoDB 没有关系型数据库中行和表的概念，不过有类似的文档和集合的概念。文档是 MongoDB 最基本的单位，每个文档都会以唯一的 _id 标识，文档的属性为 key/value 的键值对形式，文档内可以嵌套另一个文档，因此可以存储比较复杂的数据类型。集合是许多文档的总和，一个数据库可以有多个集合，一个集合可以有多个文档。</p>
<p>下面是一个 MongoDB 文档的示例： </p>
<pre><code>{ 
  <span class="string">"_id"</span> : ObjectId( <span class="string">"4f7fe8432b4a1077a7c551e8"</span> ),
  <span class="string">"name"</span> : <span class="string">"nswbmw"</span>,
  <span class="string">"age"</span> : <span class="number">22</span>,
  <span class="string">"email"</span> : [ <span class="string">"xxx@126.com"</span>, <span class="string">"xxx@gmail.com"</span> ],
  <span class="string">"family"</span> : {
    <span class="string">"mother"</span> : { ... },
    <span class="string">"father"</span> : { ... },
    <span class="string">"sister : {
      "</span>name<span class="string">" : "</span>miaomiao<span class="string">",
      "</span>age<span class="string">" : 27,
      "</span>email<span class="string">" : "</span>xxx@<span class="number">163.</span>com<span class="string">",
      "</span>family<span class="string">" : {
        "</span>mothe<span class="string">r" : { ... },
        "</span>fathe<span class="string">r" : { ... },
        "</span>brother : { ... },
        <span class="string">"husband"</span> : { ... },
        <span class="string">"son"</span> : { ... }
      }
    }
  }
}
</code></pre><p>更多有关 MongoDB 的知识请参阅 《mongodb权威指南》或查阅：<a href="http://www.mongodb.org/" target="_blank" rel="external">http://www.mongodb.org/</a></p>
<h3 id="安装MongoDB">安装MongoDB</h3><p>安装 MongoDB 很简单,去<a href="http://www.mongodb.org/downloads" target="_blank" rel="external">官网</a>下载对应系统的 MongoDB 压缩包即可。解压后将文件夹重命名为 mongodb，并在 mongodb 文件夹里新建 blog 文件夹作为我们博客内容的存储目录。进入到 bin 目录下：运行：</p>
<pre><code>mongod <span class="comment">--dbpath ../blog/</span>
</code></pre><p>以上命令的意思是:设置 blog 文件夹作为我们工程的存储目录并启动数据库。</p>
<h3 id="连接MongoDB">连接MongoDB</h3><p>数据库虽然安装并启动成功了，但我们需要连接数据库后才能使用数据库。怎么才能在 Node.js 中使用 MongoDB 呢？我们使用官方提供的 node-mongodb-native 驱动模块，打开 package.json，在 dependencies 中添加一行： </p>
<pre><code><span class="string">"mongodb"</span>: <span class="string">"1.4.15"</span>
</code></pre><p>然后运行 <code>npm install</code> 更新依赖的模块，稍等片刻后 mongodb 模块就下载并安装完成了。  </p>
<p>接下来在工程的根目录中创建 settings.js 文件，用于保存该博客工程的配置信息，比如数据库的连接信息。我们将数据库命名为 blog，因为数据库服务器在本地，所以 settings.js 文件的内容如下：</p>
<pre><code><span class="module"><span class="keyword">module</span>.exports = </span>{ 
  cookieSecret: <span class="string">'myblog'</span>, 
  db: <span class="string">'blog'</span>, 
  host: <span class="string">'localhost'</span>,
  port: <span class="number">27017</span>
}; 
</code></pre><p>其中 db 是数据库的名称，host 是数据库的地址，port是数据库的端口号，cookieSecret 用于 Cookie 加密与数据库无关，我们留作后用。</p>
<p>接下来在根目录下新建 models 文件夹，并在 models 文件夹下新建 db.js ，添加如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> settings = <span class="built_in">require</span>(<span class="string">'../settings'</span>),</span><br><span class="line">       Db = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).Db,</span><br><span class="line">       Connection = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).Connection,</span><br><span class="line">       Server = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).Server;</span><br><span class="line">   <span class="built_in">module</span>.exports = <span class="keyword">new</span> Db(settings.db, <span class="keyword">new</span> Server(settings.host, settings.port),</span><br><span class="line">&#123;safe: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中通过 <code>new Db(settings.db, new Server(settings.host, settings.port), {safe: true});</code> 设置数据库名、数据库地址和数据库端口创建了一个数据库连接实例，并通过 <code>module.exports</code> 导出该实例。这样，我们就可以通过 require 这个文件来对数据库进行读写了。</p>
<p>打开 app.js，在 <code>var routes = require(&#39;./routes/index&#39;);</code> 下添加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> settings = <span class="built_in">require</span>(<span class="string">'./settings'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="会话支持">会话支持</h3><blockquote>
<p>会话是一种持久的网络协议，用于完成服务器和客户端之间的一些交互行为。会话是一个比连接粒度更大的概念， 一次会话可能包含多次连接，每次连接都被认为是会话的一次操作。在网络应用开发中，有必要实现会话以帮助用户交互。例如网上购物的场景，用户浏览了多个页面，购买了一些物品，这些请求在多次连接中完成。许多应用层网络协议都是由会话支持的，如 FTP、Telnet 等，而 HTTP 协议是无状态的，本身不支持会话，因此在没有额外手段的帮助下，前面场景中服务器不知道用户购买了什么。 </p>
<p>为了在无状态的 HTTP 协议之上实现会话，Cookie 诞生了。Cookie 是一些存储在客户端的信息，每次连接的时候由浏览器向服务器递交，服务器也向浏览器发起存储 Cookie 的请求，依靠这样的手段服务器可以识别客户端。我们通常意义上的 HTTP 会话功能就是这样实现的。具体来说，浏览器首次向服务器发起请求时，服务器生成一个唯一标识符并发送给客户端浏览器，浏览器将这个唯一标识符存储在 Cookie 中，以后每次再发起请求，客户端浏览器都会向服务器传送这个唯一标识符，服务器通过这个唯一标识符来识别用户。 对于开发者来说，我们无须关心浏览器端的存储，需要关注的仅仅是如何通过这个唯一标识符来识别用户。很多服务端脚本语言都有会话功能，如 PHP，把每个唯一标识符存储到文件中。</p>
<p align="right">——《Node.js开发指南》</p> 

</blockquote>
<p>express 也提供了会话中间件，默认情况下是把用户信息存储在内存中，但我们既然已经有了 MongoDB，不妨把会话信息存储在数据库中，便于持久维护。为了使用这一功能，我们需要借助 express-session 和 connect-mongo 这两个第三方中间件，在 package.json 中添加： </p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"express-session"</span>: <span class="string">"1.9.1"</span>,</span><br><span class="line"><span class="string">"connect-mongo"</span>: <span class="string">"0.4.1"</span></span><br></pre></td></tr></table></figure>
<p>运行npm install安装模块,打开app.js，添加以下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="keyword">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">var</span> MongoStore = <span class="keyword">require</span>(<span class="string">'connect-mongo'</span>)(session);</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(session(&#123;</span><br><span class="line">  secret: settings.cookieSecret,</span><br><span class="line">  key: settings.db,<span class="comment">//cookie name</span></span><br><span class="line">  cookie: &#123;maxAge: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>&#125;,<span class="comment">//30 days</span></span><br><span class="line">  store: <span class="keyword">new</span> MongoStore(&#123;</span><br><span class="line">    db: settings.db,</span><br><span class="line">    host: settings.host,</span><br><span class="line">    port: settings.port</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>使用 express-session 和 connect-mongo 模块实现了将会化信息存储到mongoldb中。secret 用来防止篡改 cookie，key 的值为 cookie 的名字，通过设置 cookie 的 maxAge 值设定 cookie 的生存期，这里我们设置 cookie 的生存期为 30 天，设置它的 store 参数为 MongoStore 实例，把会话信息存储到数据库中，以避免丢失。在后面的小节中，我们可以通过 req.session 获取当前用户的会话对象，获取用户的相关信息。</p>
<h2 id="注册和登陆">注册和登陆</h2><p>我们已经准备好了数据库访问和会话的相关信息，接下来我们完成用户注册和登录功能。</p>
<h3 id="页面设计">页面设计</h3><p>首先我们来完成主页、登录页和注册页的页面设计。</p>
<p>修改 views/index.ejs 如下：  </p>
<pre><code><span class="xml"></span>&lt;%-<span class="ruby"> <span class="keyword">include</span> header </span>%&gt;<span class="xml">
这是主页
</span>&lt;%-<span class="ruby"> <span class="keyword">include</span> footer </span>%&gt;<span class="xml"></span>
</code></pre><p>在 views 文件夹下新建 header.ejs，添加如下代码：</p>
<pre><code><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>Blog<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/stylesheets/style.css"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>

<span class="tag">&lt;<span class="title">header</span>&gt;</span>
<span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;/<span class="title">header</span>&gt;</span>

<span class="tag">&lt;<span class="title">nav</span>&gt;</span>
<span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"主页"</span> <span class="attribute">href</span>=<span class="value">"/"</span>&gt;</span>home<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"登录"</span> <span class="attribute">href</span>=<span class="value">"/login"</span>&gt;</span>login<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"注册"</span> <span class="attribute">href</span>=<span class="value">"/reg"</span>&gt;</span>register<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">nav</span>&gt;</span>

<span class="tag">&lt;<span class="title">article</span>&gt;</span>
</code></pre><p>新建 footer.ejs，添加如下代码：</p>
<pre><code><span class="tag">&lt;/article&gt;</span>
<span class="tag">&lt;/body&gt;</span>
<span class="tag">&lt;/html&gt;</span>
</code></pre><p>修改 public/stylesheets/style.css 如下：</p>
<pre><code><span class="comment">/* inspired by http://yihui.name/cn/ */</span>
*<span class="rules">{<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span></span></span>;}</span>
<span class="tag">body</span><span class="rules">{<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">600px</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">2em</span> auto</span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span> <span class="number">2em</span></span></span>;<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">14px</span></span></span>;<span class="rule"><span class="attribute">font-family</span>:<span class="value"><span class="string">"Microsoft YaHei"</span></span></span>;}</span>
<span class="tag">p</span><span class="rules">{<span class="rule"><span class="attribute">line-height</span>:<span class="value"><span class="number">24px</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">1em</span> <span class="number">0</span></span></span>;}</span>
<span class="tag">header</span><span class="rules">{<span class="rule"><span class="attribute">padding</span>:<span class="value">.<span class="number">5em</span> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">border-bottom</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#cccccc</span></span></span>;}</span>
<span class="tag">nav</span><span class="rules">{<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;<span class="rule"><span class="attribute">font-family</span>:<span class="value"><span class="string">"Microsoft YaHei"</span></span></span>;<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">1.1em</span></span></span>;<span class="rule"><span class="attribute">text-transform</span>:<span class="value">uppercase</span></span>;<span class="rule"><span class="attribute">margin-left</span>:<span class="value">-<span class="number">12em</span></span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">9em</span></span></span>;<span class="rule"><span class="attribute">text-align</span>:<span class="value">right</span></span>;}</span>
<span class="tag">nav</span> <span class="tag">a</span><span class="rules">{<span class="rule"><span class="attribute">display</span>:<span class="value">block</span></span>;<span class="rule"><span class="attribute">text-decoration</span>:<span class="value">none</span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value">.<span class="number">7em</span> <span class="number">1em</span></span></span>;<span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#000000</span></span></span>;}</span>
<span class="tag">nav</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover{background-color:<span class="hexcolor">#ff0000</span></span></span>;<span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#f9f9f9</span></span></span>;<span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value">color .<span class="number">2s</span> linear</span></span>;}
<span class="tag">article</span><span class="rules">{<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">16px</span></span></span>;<span class="rule"><span class="attribute">padding-top</span>:<span class="value">.<span class="number">5em</span></span></span>;}</span>
<span class="tag">article</span> <span class="tag">a</span><span class="rules">{<span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#dd0000</span></span></span>;<span class="rule"><span class="attribute">text-decoration</span>:<span class="value">none</span></span>;}</span>
<span class="tag">article</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover{color:<span class="hexcolor">#333333</span></span></span>;<span class="rule"><span class="attribute">text-decoration</span>:<span class="value">underline</span></span>;}
<span class="class">.info</span><span class="rules">{<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">14px</span></span></span>;}</span>
</code></pre><p>运行 app ，主页显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.6.jpg?raw=true" alt=""></p>
<p>接下来在 views 文件夹下新建 login.ejs，内容如下：</p>
<pre><code>&lt;%- <span class="keyword">include</span> header %&gt;
&lt;<span class="keyword">form</span> method=<span class="string">"post"</span>&gt;
  用户名：&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;&lt;<span class="keyword">br</span> /&gt;
  密码：  &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;<span class="keyword">br</span> /&gt;
         &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"登录"</span>/&gt;
&lt;/<span class="keyword">form</span>&gt;
&lt;%- <span class="keyword">include</span> footer %&gt;
</code></pre><p>登录页面显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.7.jpg?raw=true" alt=""></p>
<p>在 views 文件夹下新建 reg.ejs，内容如下：</p>
<pre><code>&lt;%- <span class="keyword">include</span> header %&gt;
&lt;<span class="keyword">form</span> method=<span class="string">"post"</span>&gt;
  用户名：  &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;&lt;<span class="keyword">br</span> /&gt;
  密码：    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;<span class="keyword">br</span> /&gt;
  确认密码：&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"password"</span> name=<span class="string">"password-repeat"</span>/&gt;&lt;<span class="keyword">br</span> /&gt;
  邮箱：    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"email"</span> name=<span class="string">"email"</span>/&gt;&lt;<span class="keyword">br</span> /&gt;
           &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"注册"</span>/&gt;
&lt;/<span class="keyword">form</span>&gt;
&lt;%- <span class="keyword">include</span> footer %&gt;
</code></pre><p>注册页面显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.8.jpg?raw=true" alt=""></p>
<p>至此，未登录时的主页、注册页、登录页都已经完成。</p>
<p>现在，启动我们的博客看看吧。</p>
<p><strong>注意</strong>：每次我们更新代码后，都需要手动停止并重启应用，使用 supervisor 模块可以解决这个问题，每当我们保存修改的文件时，supervisor 都会自动帮我们重启应用。通过：</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> supervisor</span>
</code></pre><p>安装 supervisor 。使用 supervisor 命令启动 app.js：</p>
<pre><code><span class="variable">$ </span>supervisor app.js
</code></pre><h3 id="页面通知">页面通知</h3><p>接下来我们实现用户的注册和登陆，在这之前我们需要引入 flash 模块来实现页面通知（即成功与错误信息的显示）的功能。  </p>
<p><strong>什么是 flash?</strong></p>
<p>我们所说的 flash 即 connect-flash 模块（<a href="https://github.com/jaredhanson/connect-flash" target="_blank" rel="external">https://github.com/jaredhanson/connect-flash</a>），flash 是一个在 session 中用于存储信息的特定区域。信息写入 flash ，下一次显示完毕后即被清除。典型的应用是结合重定向的功能，确保信息是提供给下一个被渲染的页面。</p>
<p>在 package.json 添加一行代码：</p>
<pre><code><span class="string">"connect-flash"</span>: <span class="string">"0.1.1"</span>    
</code></pre><p>然后 <code>npm install</code> 安装 connect-flash 模块。修改 app.js ，在 <code>var settings = require(&#39;./settings&#39;);</code> 后添加：</p>
<pre><code><span class="keyword">var</span> flash = <span class="built_in">require</span>(<span class="string">'connect-flash'</span>);
</code></pre><p>在 <code>app.set(&#39;view engine&#39;, &#39;ejs&#39;);</code> 后添加：</p>
<pre><code><span class="keyword">app</span>.<span class="keyword">use</span>(flash());
</code></pre><p>现在我们就可以使用 flash 功能了。</p>
<h3 id="注册响应">注册响应</h3><p>前面我们已经完成了注册页，当然现在点击注册是没有效果的，因为我们还没有实现处理 POST 请求的功能，下面就来实现它。</p>
<p>在 models 文件夹下新建 user.js，添加如下代码：</p>
<pre><code><span class="keyword">var</span> mongodb = require(<span class="string">'./db'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">User</span><span class="params">(user)</span> </span>{
  <span class="keyword">this</span>.name = user.name;
  <span class="keyword">this</span>.password = user.password;
  <span class="keyword">this</span>.email = user.email;
};

module.exports = User;

<span class="comment">//存储用户信息</span>
User.prototype.save = <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>{
  <span class="comment">//要存入数据库的用户文档</span>
  <span class="keyword">var</span> user = {
      name: <span class="keyword">this</span>.name,
      password: <span class="keyword">this</span>.password,
      email: <span class="keyword">this</span>.email
  };
  <span class="comment">//打开数据库</span>
  mongodb.open(<span class="function"><span class="keyword">function</span> <span class="params">(err, db)</span> </span>{
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//错误，返回 err 信息</span>
    }
    <span class="comment">//读取 users 集合</span>
    db.collection(<span class="string">'users'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, collection)</span> </span>{
      <span class="keyword">if</span> (err) {
        mongodb.close();
        <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//错误，返回 err 信息</span>
      }
      <span class="comment">//将用户数据插入 users 集合</span>
      collection.insert(user, {
        safe: <span class="literal">true</span>
      }, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
        mongodb.close();
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//错误，返回 err 信息</span>
        }
        <span class="keyword">callback</span>(<span class="literal">null</span>, user[<span class="number">0</span>]);<span class="comment">//成功！err 为 null，并返回存储后的用户文档</span>
      });
    });
  });
};

<span class="comment">//读取用户信息</span>
User.get = <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span> </span>{
  <span class="comment">//打开数据库</span>
  mongodb.open(<span class="function"><span class="keyword">function</span> <span class="params">(err, db)</span> </span>{
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//错误，返回 err 信息</span>
    }
    <span class="comment">//读取 users 集合</span>
    db.collection(<span class="string">'users'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, collection)</span> </span>{
      <span class="keyword">if</span> (err) {
        mongodb.close();
        <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//错误，返回 err 信息</span>
      }
      <span class="comment">//查找用户名（name键）值为 name 一个文档</span>
      collection.findOne({
        name: name
      }, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
        mongodb.close();
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//失败！返回 err 信息</span>
        }
        <span class="keyword">callback</span>(<span class="literal">null</span>, user);<span class="comment">//成功！返回查询的用户信息</span>
      });
    });
  });
};
</code></pre><p>我们通过 <code>User.prototype.save</code> 实现了用户信息的存储，通过 <code>User.get</code> 实现了用户信息的读取。</p>
<p>打开 index.js ，在最前面添加如下代码：  </p>
<pre><code><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>),
    User = <span class="built_in">require</span>(<span class="string">'../models/user.js'</span>);
</code></pre><p>通过 <code>require()</code> 引入 crypto 模块和 user.js 用户模型文件，crypto 是 Node.js 的一个核心模块，我们用它生成散列值来加密密码。  </p>
<p>修改 index.js 中 <code>app.post(&#39;/reg&#39;)</code> 如下：</p>
<pre><code>app.post(<span class="string">'/reg'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  <span class="keyword">var</span> name = req.body.name,
      password = req.body.password,
      password_re = req.body[<span class="string">'password-repeat'</span>];
  <span class="comment">//检验用户两次输入的密码是否一致</span>
  <span class="keyword">if</span> (password_re != password) {
    req.flash(<span class="string">'error'</span>, <span class="string">'两次输入的密码不一致!'</span>); 
    <span class="keyword">return</span> res.redirect(<span class="string">'/reg'</span>);<span class="comment">//返回注册页</span>
  }
  <span class="comment">//生成密码的 md5 值</span>
  <span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>),
      password = md5.update(req.body.password).digest(<span class="string">'hex'</span>);
  <span class="keyword">var</span> newUser = <span class="keyword">new</span> User({
      name: name,
      password: password,
      email: req.body.email
  });
  <span class="comment">//检查用户名是否已经存在 </span>
  User.<span class="keyword">get</span>(newUser.name, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
    <span class="keyword">if</span> (err) {
      req.flash(<span class="string">'error'</span>, err);
      <span class="keyword">return</span> res.redirect(<span class="string">'/'</span>);
    }
    <span class="keyword">if</span> (user) {
      req.flash(<span class="string">'error'</span>, <span class="string">'用户已存在!'</span>);
      <span class="keyword">return</span> res.redirect(<span class="string">'/reg'</span>);<span class="comment">//返回注册页</span>
    }
    <span class="comment">//如果不存在则新增用户</span>
    newUser.save(<span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
      <span class="keyword">if</span> (err) {
        req.flash(<span class="string">'error'</span>, err);
        <span class="keyword">return</span> res.redirect(<span class="string">'/reg'</span>);<span class="comment">//注册失败返回主册页</span>
      }
      req.session.user = user;<span class="comment">//用户信息存入 session</span>
      req.flash(<span class="string">'success'</span>, <span class="string">'注册成功!'</span>);
      res.redirect(<span class="string">'/'</span>);<span class="comment">//注册成功后返回主页</span>
    });
  });
});
</code></pre><p><strong>注意</strong>：我们把用户信息存储在了 session 里，以后就可以通过 req.session.user 读取用户信息。</p>
<ul>
<li><strong>req.body</strong>： 就是 POST 请求信息解析过后的对象，例如我们要访问 POST 来的表单内的 name=”password” 域的值，只需访问 req.body[‘password’] 或 req.body.password 即可。</li>
<li><strong>res.redirect</strong>： 重定向功能，实现了页面的跳转，更多关于 res.redirect 的信息请查阅：<a href="http://expressjs.com/api.html#res.redirect" target="_blank" rel="external">http://expressjs.com/api.html#res.redirect</a> 。</li>
<li><strong>User</strong>：在前面的代码中，我们直接使用了 User 对象。User 是一个描述数据的对象，即 MVC<br>架构中的模型。前面我们使用了许多视图和控制器，这是第一次接触到模型。与视图和控制器不同，模型是真正与数据打交道的工具，没有模型，网站就只是一个外壳，不能发挥真实的作用，因此它是框架中最根本的部分。</li>
</ul>
<p>现在，启动应用，在浏览器输入 localhost:3000 注册试试吧！注册成功后显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.11.jpg?raw=true" alt=""></p>
<p>这样我们并不知道是否注册成功，我们查看数据库中是否存入了用户的信息，打开一个命令行切换到 mongodb/bin/ （保证数据库已打开的前提下），输入：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.12.jpg?raw=true" alt=""></p>
<p>可以看到，用户信息已经成功存入数据库。</p>
<p>接下来我们实现当注册成功返回主页时，左侧导航显示 HOME 、POST 、LOGOUT ，右侧显示 <strong>注册成功！</strong> 字样，即添加 flash 的页面通知功能。</p>
<p>修改 header.ejs，将 <code>&lt;nav&gt;&lt;/nav&gt;</code> 修改如下：</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">nav</span>&gt;</span>
<span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"主页"</span> <span class="attribute">href</span>=<span class="value">"/"</span>&gt;</span>home<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</span>&lt;%<span class="ruby"> <span class="keyword">if</span> (user) { </span>%&gt;<span class="xml">
  <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"发表"</span> <span class="attribute">href</span>=<span class="value">"/post"</span>&gt;</span>post<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
  <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"登出"</span> <span class="attribute">href</span>=<span class="value">"/logout"</span>&gt;</span>logout<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</span>&lt;%<span class="ruby"> } <span class="keyword">else</span> { </span>%&gt;<span class="xml">
  <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"登录"</span> <span class="attribute">href</span>=<span class="value">"/login"</span>&gt;</span>login<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
  <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">title</span>=<span class="value">"注册"</span> <span class="attribute">href</span>=<span class="value">"/reg"</span>&gt;</span>register<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</span>&lt;%<span class="ruby"> } </span>%&gt;<span class="xml">
<span class="tag">&lt;/<span class="title">nav</span>&gt;</span></span>
</code></pre><p>在 <code>&lt;article&gt;</code> 后添加如下代码：</p>
<pre><code>&lt;<span class="preprocessor">%</span> <span class="keyword">if</span> <span class="comment">(success)</span> { <span class="preprocessor">%</span>&gt;
  &lt;div&gt;&lt;<span class="preprocessor">%</span>= success <span class="preprocessor">%</span>&gt;&lt;/div&gt;
&lt;<span class="preprocessor">%</span> } <span class="preprocessor">%</span>&gt;
&lt;<span class="preprocessor">%</span> <span class="keyword">if</span> <span class="comment">(error)</span> { <span class="preprocessor">%</span>&gt;
  &lt;div&gt;&lt;<span class="preprocessor">%</span>= error <span class="preprocessor">%</span>&gt; &lt;/div&gt;
&lt;<span class="preprocessor">%</span> } <span class="preprocessor">%</span>&gt;
</code></pre><p>修改 index.js ，将 <code>app.get(&#39;/&#39;)</code> 修改如下：</p>
<pre><code><span class="tag">app</span><span class="class">.get</span>(<span class="string">'/'</span>, function (req, res) {
  <span class="tag">res</span><span class="class">.render</span>(<span class="string">'index'</span>, {
    <span class="attribute">title</span>: <span class="string">'主页'</span>,
    <span class="attribute">user</span>: req.session.user,
    <span class="attribute">success</span>: req.<span class="function">flash</span>(<span class="string">'success'</span>).<span class="function">toString</span>(),
    <span class="attribute">error</span>: req.<span class="function">flash</span>(<span class="string">'error'</span>).<span class="function">toString</span>()
  });
});
</code></pre><p>将 <code>app.get(&#39;reg&#39;)</code> 修改如下：</p>
<pre><code><span class="tag">app</span><span class="class">.get</span>(<span class="string">'/reg'</span>, function (req, res) {
  <span class="tag">res</span><span class="class">.render</span>(<span class="string">'reg'</span>, {
    <span class="attribute">title</span>: <span class="string">'注册'</span>,
    <span class="attribute">user</span>: req.session.user,
    <span class="attribute">success</span>: req.<span class="function">flash</span>(<span class="string">'success'</span>).<span class="function">toString</span>(),
    <span class="attribute">error</span>: req.<span class="function">flash</span>(<span class="string">'error'</span>).<span class="function">toString</span>()
  });
});
</code></pre><p>现在运行我们的博客，注册成功后显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.13.jpg?raw=true" alt=""></p>
<p>我们通过对 session 的使用实现了对用户状态的检测，再根据不同的用户状态显示不同的导航信息。<br>简单解释一下流程：用户在注册成功后，把用户信息存入 session ，页面跳转到主页显示 <strong>注册成功！</strong> 的字样。同时把 session 中的用户信息赋给变量 user ，在渲染 index.ejs 文件时通过检测 user 判断用户是否在线，根据用户状态的不同显示不同的导航信息。</p>
<p><code>success: req.flash(&#39;success&#39;).toString()</code> 的意思是将成功的信息赋值给变量 <code>success</code>， <code>error: req.flash(&#39;error&#39;).toString()</code> 的意思是将错误的信息赋值给变量  <code>error</code> ，然后我们在渲染 ejs 模版文件时传递这两个变量来进行检测并显示通知。</p>
<h3 id="登录与登出响应">登录与登出响应</h3><p>现在我们来实现用户登录的功能。</p>
<p>打开 index.js ，将 <code>app.post(&#39;/login&#39;)</code> 修改如下：</p>
<pre><code>app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  <span class="comment">//生成密码的 md5 值</span>
  <span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>),
      password = md5.update(req.body.password).digest(<span class="string">'hex'</span>);
  <span class="comment">//检查用户是否存在</span>
  User.<span class="keyword">get</span>(req.body.name, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
    <span class="keyword">if</span> (!user) {
      req.flash(<span class="string">'error'</span>, <span class="string">'用户不存在!'</span>); 
      <span class="keyword">return</span> res.redirect(<span class="string">'/login'</span>);<span class="comment">//用户不存在则跳转到登录页</span>
    }
    <span class="comment">//检查密码是否一致</span>
    <span class="keyword">if</span> (user.password != password) {
      req.flash(<span class="string">'error'</span>, <span class="string">'密码错误!'</span>); 
      <span class="keyword">return</span> res.redirect(<span class="string">'/login'</span>);<span class="comment">//密码错误则跳转到登录页</span>
    }
    <span class="comment">//用户名密码都匹配后，将用户信息存入 session</span>
    req.session.user = user;
    req.flash(<span class="string">'success'</span>, <span class="string">'登陆成功!'</span>);
    res.redirect(<span class="string">'/'</span>);<span class="comment">//登陆成功后跳转到主页</span>
  });
});
</code></pre><p>将 <code>app.get(&#39;/login&#39;)</code> 修改如下：</p>
<pre><code><span class="tag">app</span><span class="class">.get</span>(<span class="string">'/login'</span>, function (req, res) {
    <span class="tag">res</span><span class="class">.render</span>(<span class="string">'login'</span>, {
        <span class="attribute">title</span>: <span class="string">'登录'</span>,
        <span class="attribute">user</span>: req.session.user,
        <span class="attribute">success</span>: req.<span class="function">flash</span>(<span class="string">'success'</span>).<span class="function">toString</span>(),
        <span class="attribute">error</span>: req.<span class="function">flash</span>(<span class="string">'error'</span>).<span class="function">toString</span>()});
});
</code></pre><p>(这样就不会出现 ‘user is not defined’ 的错误了)</p>
<p>接下来我们实现登出响应。修改 <code>app.get(&#39;/logout&#39;)</code> 如下：</p>
<pre><code>app.<span class="keyword">get</span>(<span class="string">'/logout'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  req.session.user = <span class="literal">null</span>;
  req.flash(<span class="string">'success'</span>, <span class="string">'登出成功!'</span>);
  res.redirect(<span class="string">'/'</span>);<span class="comment">//登出成功后跳转到主页</span>
});
</code></pre><p><strong>注意：</strong>通过把 req.session.user 赋值 null 丢掉 session 中用户的信息，实现用户的退出。</p>
<p>登录后页面显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.14.jpg?raw=true" alt=""></p>
<p>登出后页面显示如下：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.15.jpg?raw=true" alt=""></p>
<p>至此，我们实现了用户注册与登陆的功能，并且根据用户登录状态显示不同的导航。</p>
<h3 id="页面权限控制">页面权限控制</h3><p>我们虽然已经完成了用户注册与登陆的功能，但并不能阻止比如已经登陆的用户访问 localhost:3000/reg 页面，读者可亲自尝试下。为此，我们需要为页面设置访问权限。即注册和登陆页面应该阻止已登陆的用户访问，登出及后面我们将要实现的发表页只对已登录的用户开放。如何实现页面权限的控制呢？我们可以把用户登录状态的检查放到路由中间件中，在每个路径前增加路由中间件，即可实现页面权限控制。我们添加 <code>checkNotLogin</code> 和 <code>checkLogin</code> 函数来实现这个功能。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span><span class="params">(req, res, next)</span></span> {
  <span class="keyword">if</span> (!req.session.user) {
    req.flash(<span class="string">'error'</span>, <span class="string">'未登录!'</span>); 
    res.redirect(<span class="string">'/login'</span>);
  }
  <span class="built_in">next</span>();
}

<span class="function"><span class="keyword">function</span> <span class="title">checkNotLogin</span><span class="params">(req, res, next)</span></span> {
  <span class="keyword">if</span> (req.session.user) {
    req.flash(<span class="string">'error'</span>, <span class="string">'已登录!'</span>); 
    res.redirect(<span class="string">'back'</span>);//返回之前的页面
  }
  <span class="built_in">next</span>();
}
</code></pre><p><code>checkNotLogin</code> 和 <code>checkLogin</code> 用来检测是否登陆，并通过 <code>next()</code> 转移控制权，检测到未登录则跳转到登录页，检测到已登录则跳转到前一个页面。</p>
<p>最终 index.js 代码如下：</p>
<pre><code><span class="keyword">var</span> crypto = require(<span class="string">'crypto'</span>),
    User = require(<span class="string">'../models/user.js'</span>);

module.exports = <span class="function"><span class="keyword">function</span><span class="params">(app)</span> </span>{
  app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'index'</span>, {
      title: <span class="string">'主页'</span>,
      user: req.session.user,
      success: req.flash(<span class="string">'success'</span>).toString(),
      error: req.flash(<span class="string">'error'</span>).toString()
    });
  });

  app.<span class="keyword">get</span>(<span class="string">'/reg'</span>, checkNotLogin);
  app.<span class="keyword">get</span>(<span class="string">'/reg'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'reg'</span>, {
      title: <span class="string">'注册'</span>,
      user: req.session.user,
      success: req.flash(<span class="string">'success'</span>).toString(),
      error: req.flash(<span class="string">'error'</span>).toString()
    });
  });

  app.post(<span class="string">'/reg'</span>, checkNotLogin);
  app.post(<span class="string">'/reg'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> name = req.body.name,
        password = req.body.password,
        password_re = req.body[<span class="string">'password-repeat'</span>];
    <span class="keyword">if</span> (password_re != password) {
      req.flash(<span class="string">'error'</span>, <span class="string">'两次输入的密码不一致!'</span>); 
      <span class="keyword">return</span> res.redirect(<span class="string">'/reg'</span>);
    }
    <span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>),
        password = md5.update(req.body.password).digest(<span class="string">'hex'</span>);
    <span class="keyword">var</span> newUser = <span class="keyword">new</span> User({
        name: name,
        password: password,
        email: req.body.email
    });
    User.<span class="keyword">get</span>(newUser.name, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
      <span class="keyword">if</span> (err) {
        req.flash(<span class="string">'error'</span>, err);
        <span class="keyword">return</span> res.redirect(<span class="string">'/'</span>);
      }
      <span class="keyword">if</span> (user) {
        req.flash(<span class="string">'error'</span>, <span class="string">'用户已存在!'</span>);
        <span class="keyword">return</span> res.redirect(<span class="string">'/reg'</span>);
      }
      newUser.save(<span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
        <span class="keyword">if</span> (err) {
          req.flash(<span class="string">'error'</span>, err);
          <span class="keyword">return</span> res.redirect(<span class="string">'/reg'</span>);
        }
        req.session.user = user;
        req.flash(<span class="string">'success'</span>, <span class="string">'注册成功!'</span>);
        res.redirect(<span class="string">'/'</span>);
      });
    });
  });

  app.<span class="keyword">get</span>(<span class="string">'/login'</span>, checkNotLogin);
  app.<span class="keyword">get</span>(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'login'</span>, {
      title: <span class="string">'登录'</span>,
      user: req.session.user,
      success: req.flash(<span class="string">'success'</span>).toString(),
      error: req.flash(<span class="string">'error'</span>).toString()
    }); 
  });

  app.post(<span class="string">'/login'</span>, checkNotLogin);
  app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>),
        password = md5.update(req.body.password).digest(<span class="string">'hex'</span>);
    User.<span class="keyword">get</span>(req.body.name, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span> </span>{
      <span class="keyword">if</span> (!user) {
        req.flash(<span class="string">'error'</span>, <span class="string">'用户不存在!'</span>); 
        <span class="keyword">return</span> res.redirect(<span class="string">'/login'</span>);
      }
      <span class="keyword">if</span> (user.password != password) {
        req.flash(<span class="string">'error'</span>, <span class="string">'密码错误!'</span>); 
        <span class="keyword">return</span> res.redirect(<span class="string">'/login'</span>);
      }
      req.session.user = user;
      req.flash(<span class="string">'success'</span>, <span class="string">'登陆成功!'</span>);
      res.redirect(<span class="string">'/'</span>);
    });
  });

  app.<span class="keyword">get</span>(<span class="string">'/post'</span>, checkLogin);
  app.<span class="keyword">get</span>(<span class="string">'/post'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    res.render(<span class="string">'post'</span>, {
      title: <span class="string">'发表'</span>,
      user: req.session.user,
      success: req.flash(<span class="string">'success'</span>).toString(),
      error: req.flash(<span class="string">'error'</span>).toString()
    });
  });

  app.post(<span class="string">'/post'</span>, checkLogin);
  app.post(<span class="string">'/post'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  });

  app.<span class="keyword">get</span>(<span class="string">'/logout'</span>, checkLogin);
  app.<span class="keyword">get</span>(<span class="string">'/logout'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    req.session.user = <span class="literal">null</span>;
    req.flash(<span class="string">'success'</span>, <span class="string">'登出成功!'</span>);
    res.redirect(<span class="string">'/'</span>);
  });

  <span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span><span class="params">(req, res, next)</span> </span>{
    <span class="keyword">if</span> (!req.session.user) {
      req.flash(<span class="string">'error'</span>, <span class="string">'未登录!'</span>); 
      res.redirect(<span class="string">'/login'</span>);
    }
    next();
  }

  <span class="function"><span class="keyword">function</span> <span class="title">checkNotLogin</span><span class="params">(req, res, next)</span> </span>{
    <span class="keyword">if</span> (req.session.user) {
      req.flash(<span class="string">'error'</span>, <span class="string">'已登录!'</span>); 
      res.redirect(<span class="string">'back'</span>);
    }
    next();
  }
};
</code></pre><p><strong>注意：</strong>为了维护用户状态和 flash 的通知功能，我们给每个 ejs 模版文件传入了以下三个值：</p>
<pre><code>user: req<span class="class">.session</span><span class="class">.user</span>,
success: req.<span class="function"><span class="title">flash</span><span class="params">(<span class="string">'success'</span>)</span></span>.<span class="function"><span class="title">toString</span><span class="params">()</span></span>,
error: req.<span class="function"><span class="title">flash</span><span class="params">(<span class="string">'error'</span>)</span></span>.<span class="function"><span class="title">toString</span><span class="params">()</span></span>
</code></pre><h2 id="发表文章">发表文章</h2><p>现在我们的博客已经具备了用户注册、登陆、页面权限控制的功能，接下来我们完成博客最核心的部分——发表文章。在这一节，我们将会实现发表文章的功能，完成整个博客的设计。</p>
<h3 id="页面设计-1">页面设计</h3><p>我们先来完成发表页的页面设计。在 views 文件夹下新建 post.ejs ，添加如下代码：</p>
<pre><code><span class="xml"></span>&lt;%-<span class="ruby"> <span class="keyword">include</span> header </span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span>
  标题：<span class="tag">&lt;<span class="title">br</span> /&gt;</span>
  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"title"</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span>
  正文：<span class="tag">&lt;<span class="title">br</span> /&gt;</span>
  <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">name</span>=<span class="value">"post"</span> <span class="attribute">rows</span>=<span class="value">"20"</span> <span class="attribute">cols</span>=<span class="value">"100"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span>
  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">value</span>=<span class="value">"发表"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</span>&lt;%-<span class="ruby"> <span class="keyword">include</span> footer </span>%&gt;<span class="xml"></span>
</code></pre><h3 id="文章模型">文章模型</h3><p>仿照用户模型，我们将文章模型命名为 Post 对象，它拥有与 User 相似的接口，分别是 <code>Post.get</code> 和 <code>Post.prototype.save</code> 。<code>Post.get</code> 的功能是从数据库中获取文章，可以按指定用户获取，也可以获取全部的内容。<code>Post.prototype.save</code> 是 Post 对象原型的方法，用来将文章保存到数据库。<br>在 models 文件夹下新建 post.js ，添加如下代码：</p>
<pre><code><span class="keyword">var</span> mongodb = require(<span class="string">'./db'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">Post</span><span class="params">(name, title, post)</span> </span>{
  <span class="keyword">this</span>.name = name;
  <span class="keyword">this</span>.title = title;
  <span class="keyword">this</span>.post = post;
}

module.exports = Post;

<span class="comment">//存储一篇文章及其相关信息</span>
Post.prototype.save = <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>{
  <span class="keyword">var</span> date = <span class="keyword">new</span> Date();
  <span class="comment">//存储各种时间格式，方便以后扩展</span>
  <span class="keyword">var</span> time = {
      date: date,
      year : date.getFullYear(),
      month : date.getFullYear() + <span class="string">"-"</span> + (date.getMonth() + <span class="number">1</span>),
      day : date.getFullYear() + <span class="string">"-"</span> + (date.getMonth() + <span class="number">1</span>) + <span class="string">"-"</span> + date.getDate(),
      minute : date.getFullYear() + <span class="string">"-"</span> + (date.getMonth() + <span class="number">1</span>) + <span class="string">"-"</span> + date.getDate() + <span class="string">" "</span> + 
      date.getHours() + <span class="string">":"</span> + (date.getMinutes() &lt; <span class="number">10</span> ? <span class="string">'0'</span> + date.getMinutes() : date.getMinutes()) 
  }
  <span class="comment">//要存入数据库的文档</span>
  <span class="keyword">var</span> post = {
      name: <span class="keyword">this</span>.name,
      time: time,
      title: <span class="keyword">this</span>.title,
      post: <span class="keyword">this</span>.post
  };
  <span class="comment">//打开数据库</span>
  mongodb.open(<span class="function"><span class="keyword">function</span> <span class="params">(err, db)</span> </span>{
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> <span class="keyword">callback</span>(err);
    }
    <span class="comment">//读取 posts 集合</span>
    db.collection(<span class="string">'posts'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, collection)</span> </span>{
      <span class="keyword">if</span> (err) {
        mongodb.close();
        <span class="keyword">return</span> <span class="keyword">callback</span>(err);
      }
      <span class="comment">//将文档插入 posts 集合</span>
      collection.insert(post, {
        safe: <span class="literal">true</span>
      }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{
        mongodb.close();
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//失败！返回 err</span>
        }
        <span class="keyword">callback</span>(<span class="literal">null</span>);<span class="comment">//返回 err 为 null</span>
      });
    });
  });
};

<span class="comment">//读取文章及其相关信息</span>
Post.get = <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span> </span>{
  <span class="comment">//打开数据库</span>
  mongodb.open(<span class="function"><span class="keyword">function</span> <span class="params">(err, db)</span> </span>{
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> <span class="keyword">callback</span>(err);
    }
    <span class="comment">//读取 posts 集合</span>
    db.collection(<span class="string">'posts'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, collection)</span> </span>{
      <span class="keyword">if</span> (err) {
        mongodb.close();
        <span class="keyword">return</span> <span class="keyword">callback</span>(err);
      }
      <span class="keyword">var</span> query = {};
      <span class="keyword">if</span> (name) {
        query.name = name;
      }
      <span class="comment">//根据 query 对象查询文章</span>
      collection.find(query).sort({
        time: -<span class="number">1</span>
      }).toArray(<span class="function"><span class="keyword">function</span> <span class="params">(err, docs)</span> </span>{
        mongodb.close();
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> <span class="keyword">callback</span>(err);<span class="comment">//失败！返回 err</span>
        }
        <span class="keyword">callback</span>(<span class="literal">null</span>, docs);<span class="comment">//成功！以数组形式返回查询的结果</span>
      });
    });
  });
};
</code></pre><h3 id="发表响应">发表响应</h3><p>接下来我们给发表文章注册响应，打开 index.js ，在 <code>User = require(&#39;../models/user.js&#39;)</code> 后添加一行代码：</p>
<pre><code>,Post = <span class="built_in">require</span>(<span class="string">'../models/post.js'</span>);
</code></pre><p>修改 <code>app.post(&#39;/post&#39;)</code> 如下：</p>
<pre><code><span class="keyword">app</span>.<span class="keyword">post</span>('/<span class="keyword">post</span>', checkLogin);
<span class="keyword">app</span>.<span class="keyword">post</span>('/<span class="keyword">post</span>', function (req, res) {
  <span class="keyword">var</span> currentUser = req.session.user,
      <span class="keyword">post</span> = new <span class="keyword">Post</span>(currentUser.name, req.body.title, req.body.<span class="keyword">post</span>);
  <span class="keyword">post</span>.<span class="keyword">save</span>(function (<span class="keyword">err</span>) {
    <span class="keyword">if</span> (<span class="keyword">err</span>) {
      req.flash('<span class="keyword">error</span>', <span class="keyword">err</span>); 
      <span class="keyword">return</span> res.redirect('/');
    }
    req.flash('success', '发布成功!');
    res.redirect('/');<span class="comment">//发表成功跳转到主页</span>
  });
});
</code></pre><p>最后，我们修改 index.ejs ，让主页右侧显示发表过的文章及其相关信息。</p>
<p>打开 index.ejs ，修改如下：</p>
<pre><code><span class="xml"></span><span class="vbscript">&lt;%- include header %&gt;</span><span class="xml">
</span><span class="vbscript">&lt;% posts.forEach(<span class="keyword">function</span> (post, index) { %&gt;</span><span class="xml">
  <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span></span><span class="vbscript">&lt;%= post.title %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">h2</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"info"</span>&gt;</span>
    作者：<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span></span><span class="vbscript">&lt;%= post.name %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span> | 
    日期：</span><span class="vbscript">&lt;%= post.<span class="built_in">time</span>.<span class="built_in">minute</span> %&gt;</span><span class="xml">
  <span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="vbscript">&lt;%- post.post %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</span><span class="vbscript">&lt;% }) %&gt;</span><span class="xml">
</span><span class="vbscript">&lt;%- include footer %&gt;</span><span class="xml"></span>
</code></pre><p>打开 index.js ，修改 <code>app.get(&#39;/&#39;)</code> 如下：</p>
<pre><code>app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
  Post.<span class="keyword">get</span>(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, posts)</span> </span>{
    <span class="keyword">if</span> (err) {
      posts = [];
    } 
    res.render(<span class="string">'index'</span>, {
      title: <span class="string">'主页'</span>,
      user: req.session.user,
      posts: posts,
      success: req.flash(<span class="string">'success'</span>).toString(),
      error: req.flash(<span class="string">'error'</span>).toString()
    });
  });
});
</code></pre><p>至此，我们的博客就建成了。</p>
<p>启动我们的博客，发表一篇博文，如图所示:</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.16.jpg?raw=true" alt=""></p>
<p>此时，查看一下数据库，如图所示：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.17.jpg?raw=true" alt=""></p>
<p><strong>Tips</strong>：Robomongo 是一个基于 Shell 的跨平台开源 MongoDB 管理工具。嵌入了 JavaScript 引擎和 MongoDB mongo 。只要你会使用 mongo shell ，你就会使用 Robomongo，它提供语法高亮、自动完成、差别视图等。</p>
<p>下载安装 Robomongo后，运行我们的博客，注册一个用户并发表几篇文章，初次打开 Robomongo ，点击 <strong>Create</strong> 创建一个名为 blog （名字自定）的数据库链接（默认监听 localhost:27017），点击 <strong>Connect</strong> 就连接到数据库了。如图所示：</p>
<p><img src="https://github.com/nswbmw/N-blog/blob/master/public/images/1.18.jpg?raw=true" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="学习环境">学习环境</h2><p><strong>Node.js</strong> ： 0.10.32</p>
<p><strong>Express</strong> ： 4.10.2</p>
<p><strong>MongoDB</strong> ： 2.6.1</p>
<h2 id="快速开始">快速开始</h2><h3 id="安装_Express">安装 Express</h3><p>express 是 Node.js 上最流行的 Web 开发框架，正如他的名字一样，使用它我们可以快速的开发一个 Web 应用。我们用 express 来搭建我们的博客，打开命令行，输入：</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> express-generator</span>
</code></pre><p>安装 express 命令行工具，使用它我们可以初始化一个 express 项目。<br>]]>
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery设计理念]]></title>
    <link href="http://yoursite.com/2015/09/15/jQuery%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/"/>
    <id>http://yoursite.com/2015/09/15/jQuery设计理念/</id>
    <published>2015-09-15T09:19:26.000Z</published>
    <updated>2015-09-15T12:50:37.266Z</updated>
    <content type="html"><![CDATA[<p>jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p>
<p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！<br><a id="more"></a></p>
<h4 id="简洁的API:">简洁的API:</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$<span class="class">.on</span></span><br><span class="line">$<span class="class">.css</span></span><br><span class="line">$<span class="class">.ajax</span></span><br><span class="line">….</span><br></pre></td></tr></table></figure>
<h4 id="优雅的链式:">优雅的链式:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax( <span class="string">"example.php"</span> )</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"success"</span>); &#125;)</span><br><span class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"error"</span>); &#125;)</span><br><span class="line">    .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"complete"</span>); &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="强大的选择器：">强大的选择器：</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"div, span, p.myClass"</span> )</span><br><span class="line"><span class="variable">$(</span><span class="string">"div span:first-child"</span>)</span><br><span class="line"><span class="variable">$(</span><span class="string">"tr:visible"</span>)</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<h4 id="便捷的操作：">便捷的操作：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).removeClass(<span class="string">"myClass noClass"</span>).addClass(<span class="string">"yourClass"</span>);</span><br><span class="line">$(<span class="string">"ul li:last"</span>).addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span><span class="string">"item-"</span> + index;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'.container'</span>).append($(<span class="string">'h2'</span>));</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<h4 id="相关问题">相关问题</h4><hr>
<p><strong>为什么要做jQuery源码解析？</strong></p>
<p>虽然<em>jQuery</em>的文档很完善，潜意识降低了前端开发的入门的门槛，要实现一个动画随手拈来，只要简单的调用一个animate方法传递几个执行的参数即可，但如果要我们自己实现一个定制的动画呢？我们要考虑的问题太多太多了，浏览器兼容、各种属性的获取、逻辑流程、性能等等，这些才是前端开发的基础核心。</p>
<p>如果我们只知道使用jQuery，而不知道其原理，那就是“知其然,而不知其所以然”，说了这么多，那就赶快跟着慕课网进入“高大上”之旅吧，深入来探究jQuery的内部架构！<br><strong>jquery1.xx.xx版本的写法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>jQuery为什么要创建这样的一个外层包裹，其原理又是如何？</strong></p>
<p>这里要区分2个概念一个是匿名函数，一个是自执行。顾名思义，匿名函数，就是没有函数名的函数，也就是不存在外部引用。但是是否像下面代码实现呢：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种写法是错了，声明了它但是又不给名字又没有使用，所以在语法上错误的，那么怎么去执行一个匿名的函数呢？<br>要调用一个函数，我们必须要有方法定位它、引用它。所以，我们要取一个名字：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表），那么这小括号能把我们的表达式组合分块，并且每一块（也就是每一对小括号），都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的，就是一个匿名函数的Function对象。<strong>因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。</strong> 所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。</p>
<p><strong>总结：全局变量是魔鬼, 匿名函数可以有效的保证在页面上写入JavaScript，而不会造成全局变量的污染，通过小括号，让其加载的时候立即初始化，这样就形成了一个单例模式的效果从而只会执行一次。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p>
<p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！<br>]]>
    
    </summary>
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo常用操作]]></title>
    <link href="http://yoursite.com/2015/09/13/hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2015/09/13/hexo常用操作/</id>
    <published>2015-09-13T09:19:26.000Z</published>
    <updated>2015-09-13T09:46:53.747Z</updated>
    <content type="html"><![CDATA[<h2 id="Quick_Start">Quick Start</h2><h3 id="写作">写作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="完成后部署">完成后部署</h3><p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --deploy</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Quick_Start">Quick Start</h2><h3 id="写作">写作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
